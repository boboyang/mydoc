#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class GabrielAction(object):
  REGISTRATION = 10000
  FORGOT_PASSWD = 10001
  RESET_PASSWD = 10002
  CHANGE_EMAIL = 10003
  CHANGE_PASSWD = 10004
  UPDATE_USER = 10005
  DELETE_USER = 10006
  CONFIRM_USER = 10007
  RESEND_CONFIRM_KEY = 10008
  RETRIEVE_USER = 10011
  RETRIEVE_USER_PROFILE = 10012
  LOGIN = 11003
  AUTHORIZATION = 11004
  GRANT_APP = 11005
  UNGRANT_APP = 11006
  GET_UTOKEN = 11007
  BIND_DEVICE = 11008
  UNBIND_DEVICE = 11009
  GET_DLIST = 11010
  VALIDATE_DEVICE = 11011
  RENEW_UTOKEN = 11012
  PUBLISH_DEVICE = 11013
  CANCEL_PUBLIC_DEVICE = 11014
  SEARCH_PUBLIC_DEVICE = 11015
  UPDATE_DEVICE_INFO = 11016
  ADD_FAVORITE_DEVICE = 11017
  REMOVE_FAVORITE_DEVICE = 11018
  GET_FAVORITE_DLIST = 11019
  START_VIEWING = 12000
  STOP_VIEWING = 12001
  START_RECORDING = 12002
  STOP_RECORDING = 12003
  ADD_GROUP = 14000
  REMOVE_GROUP = 14001
  MODIFY_GROUP = 14002
  GET_GROUP = 14003
  GET_GROUP_LIST = 14004
  ADD_GROUP_MEMBER = 14005
  REMOVE_GROUP_MEMBER = 14006
  GET_GMEMBER_LIST = 14007
  SHARE_TO_USER = 15000
  SHARE_TO_GROUP = 15001
  REVOKE_FROM_USER = 15002
  GET_SHARING_LIST = 15003
  GET_APPENDING_LIST = 15004
  ACCEPT_SHARING_DEVICE = 15005
  REMOVE_SHARING_DEVICE = 15006
  ENABLE_SHARING_DEVICE = 15007
  DISABLE_SHARING_DEVICE = 15008
  UPDATE_SHARING_DEVICE = 15009
  RESEND_SHARING_DEVICE = 15010
  GET_RECORDING_LIST = 16000
  DEV_LOGIN = 50000
  DEV_LINKUP = 50001
  DEV_LINKDOWN = 50002
  DEV_RELAYUP = 50003
  DEV_RELAYDOWN = 50004
  DEV_BOOTSTRAP = 50005
  DEV_CONFIG_CHANGED = 51000
  DEV_STATUS_CHANGED = 51001
  DEV_SESSION_START = 51002
  DEV_SESSION_STOP = 51003
  DEV_MOTION_DETECTED = 51004
  DEV_AUDIO_EVENT_DETECTED = 51005
  CMD_REPORT_STATUS = 60000
  CMD_CHECK_NEXUS = 60001
  CMD_ALARM_ACK = 70000
  CMD_REBOOT_DEVICE = 70001

  _VALUES_TO_NAMES = {
    10000: "REGISTRATION",
    10001: "FORGOT_PASSWD",
    10002: "RESET_PASSWD",
    10003: "CHANGE_EMAIL",
    10004: "CHANGE_PASSWD",
    10005: "UPDATE_USER",
    10006: "DELETE_USER",
    10007: "CONFIRM_USER",
    10008: "RESEND_CONFIRM_KEY",
    10011: "RETRIEVE_USER",
    10012: "RETRIEVE_USER_PROFILE",
    11003: "LOGIN",
    11004: "AUTHORIZATION",
    11005: "GRANT_APP",
    11006: "UNGRANT_APP",
    11007: "GET_UTOKEN",
    11008: "BIND_DEVICE",
    11009: "UNBIND_DEVICE",
    11010: "GET_DLIST",
    11011: "VALIDATE_DEVICE",
    11012: "RENEW_UTOKEN",
    11013: "PUBLISH_DEVICE",
    11014: "CANCEL_PUBLIC_DEVICE",
    11015: "SEARCH_PUBLIC_DEVICE",
    11016: "UPDATE_DEVICE_INFO",
    11017: "ADD_FAVORITE_DEVICE",
    11018: "REMOVE_FAVORITE_DEVICE",
    11019: "GET_FAVORITE_DLIST",
    12000: "START_VIEWING",
    12001: "STOP_VIEWING",
    12002: "START_RECORDING",
    12003: "STOP_RECORDING",
    14000: "ADD_GROUP",
    14001: "REMOVE_GROUP",
    14002: "MODIFY_GROUP",
    14003: "GET_GROUP",
    14004: "GET_GROUP_LIST",
    14005: "ADD_GROUP_MEMBER",
    14006: "REMOVE_GROUP_MEMBER",
    14007: "GET_GMEMBER_LIST",
    15000: "SHARE_TO_USER",
    15001: "SHARE_TO_GROUP",
    15002: "REVOKE_FROM_USER",
    15003: "GET_SHARING_LIST",
    15004: "GET_APPENDING_LIST",
    15005: "ACCEPT_SHARING_DEVICE",
    15006: "REMOVE_SHARING_DEVICE",
    15007: "ENABLE_SHARING_DEVICE",
    15008: "DISABLE_SHARING_DEVICE",
    15009: "UPDATE_SHARING_DEVICE",
    15010: "RESEND_SHARING_DEVICE",
    16000: "GET_RECORDING_LIST",
    50000: "DEV_LOGIN",
    50001: "DEV_LINKUP",
    50002: "DEV_LINKDOWN",
    50003: "DEV_RELAYUP",
    50004: "DEV_RELAYDOWN",
    50005: "DEV_BOOTSTRAP",
    51000: "DEV_CONFIG_CHANGED",
    51001: "DEV_STATUS_CHANGED",
    51002: "DEV_SESSION_START",
    51003: "DEV_SESSION_STOP",
    51004: "DEV_MOTION_DETECTED",
    51005: "DEV_AUDIO_EVENT_DETECTED",
    60000: "CMD_REPORT_STATUS",
    60001: "CMD_CHECK_NEXUS",
    70000: "CMD_ALARM_ACK",
    70001: "CMD_REBOOT_DEVICE",
  }

  _NAMES_TO_VALUES = {
    "REGISTRATION": 10000,
    "FORGOT_PASSWD": 10001,
    "RESET_PASSWD": 10002,
    "CHANGE_EMAIL": 10003,
    "CHANGE_PASSWD": 10004,
    "UPDATE_USER": 10005,
    "DELETE_USER": 10006,
    "CONFIRM_USER": 10007,
    "RESEND_CONFIRM_KEY": 10008,
    "RETRIEVE_USER": 10011,
    "RETRIEVE_USER_PROFILE": 10012,
    "LOGIN": 11003,
    "AUTHORIZATION": 11004,
    "GRANT_APP": 11005,
    "UNGRANT_APP": 11006,
    "GET_UTOKEN": 11007,
    "BIND_DEVICE": 11008,
    "UNBIND_DEVICE": 11009,
    "GET_DLIST": 11010,
    "VALIDATE_DEVICE": 11011,
    "RENEW_UTOKEN": 11012,
    "PUBLISH_DEVICE": 11013,
    "CANCEL_PUBLIC_DEVICE": 11014,
    "SEARCH_PUBLIC_DEVICE": 11015,
    "UPDATE_DEVICE_INFO": 11016,
    "ADD_FAVORITE_DEVICE": 11017,
    "REMOVE_FAVORITE_DEVICE": 11018,
    "GET_FAVORITE_DLIST": 11019,
    "START_VIEWING": 12000,
    "STOP_VIEWING": 12001,
    "START_RECORDING": 12002,
    "STOP_RECORDING": 12003,
    "ADD_GROUP": 14000,
    "REMOVE_GROUP": 14001,
    "MODIFY_GROUP": 14002,
    "GET_GROUP": 14003,
    "GET_GROUP_LIST": 14004,
    "ADD_GROUP_MEMBER": 14005,
    "REMOVE_GROUP_MEMBER": 14006,
    "GET_GMEMBER_LIST": 14007,
    "SHARE_TO_USER": 15000,
    "SHARE_TO_GROUP": 15001,
    "REVOKE_FROM_USER": 15002,
    "GET_SHARING_LIST": 15003,
    "GET_APPENDING_LIST": 15004,
    "ACCEPT_SHARING_DEVICE": 15005,
    "REMOVE_SHARING_DEVICE": 15006,
    "ENABLE_SHARING_DEVICE": 15007,
    "DISABLE_SHARING_DEVICE": 15008,
    "UPDATE_SHARING_DEVICE": 15009,
    "RESEND_SHARING_DEVICE": 15010,
    "GET_RECORDING_LIST": 16000,
    "DEV_LOGIN": 50000,
    "DEV_LINKUP": 50001,
    "DEV_LINKDOWN": 50002,
    "DEV_RELAYUP": 50003,
    "DEV_RELAYDOWN": 50004,
    "DEV_BOOTSTRAP": 50005,
    "DEV_CONFIG_CHANGED": 51000,
    "DEV_STATUS_CHANGED": 51001,
    "DEV_SESSION_START": 51002,
    "DEV_SESSION_STOP": 51003,
    "DEV_MOTION_DETECTED": 51004,
    "DEV_AUDIO_EVENT_DETECTED": 51005,
    "CMD_REPORT_STATUS": 60000,
    "CMD_CHECK_NEXUS": 60001,
    "CMD_ALARM_ACK": 70000,
    "CMD_REBOOT_DEVICE": 70001,
  }

class GabrielStatus(object):
  OK = 200
  MOVED = 301
  INVALID_OPERATION = 400
  INVALID_AUTH_CODE = 401
  INVALID_ACCESS_TOKEN = 402
  INVALID_DEVICE = 403
  INVALID_OWNER = 404
  INVALID_USER = 405
  INVALID_APP = 406
  UNKNOWN_USER = 407
  UNKNOWN_APP = 408
  EXISTED_ENTITY = 409
  WRONG_SITE = 410
  INVALID_TIMESTAMP = 411
  DUPLICATE_TIMESTAMP = 412
  UNAVAILABLE = 413
  TIMEOUT = 414
  INVALID_PARAM = 415

  _VALUES_TO_NAMES = {
    200: "OK",
    301: "MOVED",
    400: "INVALID_OPERATION",
    401: "INVALID_AUTH_CODE",
    402: "INVALID_ACCESS_TOKEN",
    403: "INVALID_DEVICE",
    404: "INVALID_OWNER",
    405: "INVALID_USER",
    406: "INVALID_APP",
    407: "UNKNOWN_USER",
    408: "UNKNOWN_APP",
    409: "EXISTED_ENTITY",
    410: "WRONG_SITE",
    411: "INVALID_TIMESTAMP",
    412: "DUPLICATE_TIMESTAMP",
    413: "UNAVAILABLE",
    414: "TIMEOUT",
    415: "INVALID_PARAM",
  }

  _NAMES_TO_VALUES = {
    "OK": 200,
    "MOVED": 301,
    "INVALID_OPERATION": 400,
    "INVALID_AUTH_CODE": 401,
    "INVALID_ACCESS_TOKEN": 402,
    "INVALID_DEVICE": 403,
    "INVALID_OWNER": 404,
    "INVALID_USER": 405,
    "INVALID_APP": 406,
    "UNKNOWN_USER": 407,
    "UNKNOWN_APP": 408,
    "EXISTED_ENTITY": 409,
    "WRONG_SITE": 410,
    "INVALID_TIMESTAMP": 411,
    "DUPLICATE_TIMESTAMP": 412,
    "UNAVAILABLE": 413,
    "TIMEOUT": 414,
    "INVALID_PARAM": 415,
  }

class GabrielAppType(object):
  TYPE_2 = 2
  TYPE_3 = 3

  _VALUES_TO_NAMES = {
    2: "TYPE_2",
    3: "TYPE_3",
  }

  _NAMES_TO_VALUES = {
    "TYPE_2": 2,
    "TYPE_3": 3,
  }

class GabrielServiceType(object):
  VIEWING = 0
  RECORDING = 1

  _VALUES_TO_NAMES = {
    0: "VIEWING",
    1: "RECORDING",
  }

  _NAMES_TO_VALUES = {
    "VIEWING": 0,
    "RECORDING": 1,
  }

class GabrielConnType(object):
  LOCAL = 0
  DIRECT = 1
  RELAY = 2

  _VALUES_TO_NAMES = {
    0: "LOCAL",
    1: "DIRECT",
    2: "RELAY",
  }

  _NAMES_TO_VALUES = {
    "LOCAL": 0,
    "DIRECT": 1,
    "RELAY": 2,
  }

class GabrielDeviceType(object):
  PRIVATE = 0
  OTHERS = 1
  PUBLIC = 2
  SHARED = 4
  VIEW = 8
  NOTIFY = 16
  PROVISION = 32
  PLAYBACK = 64

  _VALUES_TO_NAMES = {
    0: "PRIVATE",
    1: "OTHERS",
    2: "PUBLIC",
    4: "SHARED",
    8: "VIEW",
    16: "NOTIFY",
    32: "PROVISION",
    64: "PLAYBACK",
  }

  _NAMES_TO_VALUES = {
    "PRIVATE": 0,
    "OTHERS": 1,
    "PUBLIC": 2,
    "SHARED": 4,
    "VIEW": 8,
    "NOTIFY": 16,
    "PROVISION": 32,
    "PLAYBACK": 64,
  }

class GabrielDeviceNotification(object):
  EMAIL = 1
  SMS = 2

  _VALUES_TO_NAMES = {
    1: "EMAIL",
    2: "SMS",
  }

  _NAMES_TO_VALUES = {
    "EMAIL": 1,
    "SMS": 2,
  }

class GabrielSharingStatus(object):
  PENDING = 0
  ACCEPTED = 1
  SUSPENDED = 2

  _VALUES_TO_NAMES = {
    0: "PENDING",
    1: "ACCEPTED",
    2: "SUSPENDED",
  }

  _NAMES_TO_VALUES = {
    "PENDING": 0,
    "ACCEPTED": 1,
    "SUSPENDED": 2,
  }

class GabrielAuthorizeStatus(object):
  WAITING = 0
  GRANTED = 1

  _VALUES_TO_NAMES = {
    0: "WAITING",
    1: "GRANTED",
  }

  _NAMES_TO_VALUES = {
    "WAITING": 0,
    "GRANTED": 1,
  }

class EVT_KEY(object):
  TAG_STRING = 0
  TAG_FROM = 1
  TAG_TO = 2
  TAG_APP = 3
  TAG_SID = 4
  TAG_ACTION = 5
  TAG_DEVICENAME = 6
  TAG_DEVICEMAC = 7
  TAG_USERNAME = 8
  TAG_PASSWORD = 9
  TAG_LOCALIP = 10
  TAG_VERSION = 11
  TAG_ACTION_RESULT = 12
  TAG_URL = 13
  TAG_IP = 14
  TAG_PORT = 15
  TAG_ID8 = 16
  TAG_IP_STUNT1 = 17
  TAG_IP_STUNT2 = 18
  TAG_IP_RELAY = 19
  TAG_PORT_HTTP = 20
  TAG_PORT_HTTPS = 21
  TAG_CAPABILITY = 22
  TAG_ACCESSKEY = 23
  TAG_PORT_LIVEVIEW = 24
  TAG_PORT_PLAYBACK = 25
  TAG_PROXY = 26
  TAG_REGISTER_STATUS = 27
  TAG_PEER_ID8 = 28
  TAG_SYSTEM_VERSION = 29
  TAG_RELAY_CTRL_PORT = 30
  TAG_RELAY_DATA_PORT = 31
  TAG_DEVICE_EXT_IP = 32
  TAG_EVENT_SRC_IP = 38
  TAG_EVENT_DST_IP = 39
  TAG_CHUNK_TYPE = 40
  TAG_INTEGER = 4096
  TAG_TID = 4097
  TAG_STATUS = 4098
  TAG_ERR = 4099
  TAG_EVENT_ID = 4100
  TAG_CHUNK_NUMBER = 4101
  TAG_EVENT_TIME = 4352
  TAG_BINARY = 8192
  TAG_PAYLOAD = 8193
  TAG_ENCRYPT_B64 = 8194
  TAG_TUNNEL_KEY = 8195
  TAG_CHUNK_DATA = 8196

  _VALUES_TO_NAMES = {
    0: "TAG_STRING",
    1: "TAG_FROM",
    2: "TAG_TO",
    3: "TAG_APP",
    4: "TAG_SID",
    5: "TAG_ACTION",
    6: "TAG_DEVICENAME",
    7: "TAG_DEVICEMAC",
    8: "TAG_USERNAME",
    9: "TAG_PASSWORD",
    10: "TAG_LOCALIP",
    11: "TAG_VERSION",
    12: "TAG_ACTION_RESULT",
    13: "TAG_URL",
    14: "TAG_IP",
    15: "TAG_PORT",
    16: "TAG_ID8",
    17: "TAG_IP_STUNT1",
    18: "TAG_IP_STUNT2",
    19: "TAG_IP_RELAY",
    20: "TAG_PORT_HTTP",
    21: "TAG_PORT_HTTPS",
    22: "TAG_CAPABILITY",
    23: "TAG_ACCESSKEY",
    24: "TAG_PORT_LIVEVIEW",
    25: "TAG_PORT_PLAYBACK",
    26: "TAG_PROXY",
    27: "TAG_REGISTER_STATUS",
    28: "TAG_PEER_ID8",
    29: "TAG_SYSTEM_VERSION",
    30: "TAG_RELAY_CTRL_PORT",
    31: "TAG_RELAY_DATA_PORT",
    32: "TAG_DEVICE_EXT_IP",
    38: "TAG_EVENT_SRC_IP",
    39: "TAG_EVENT_DST_IP",
    40: "TAG_CHUNK_TYPE",
    4096: "TAG_INTEGER",
    4097: "TAG_TID",
    4098: "TAG_STATUS",
    4099: "TAG_ERR",
    4100: "TAG_EVENT_ID",
    4101: "TAG_CHUNK_NUMBER",
    4352: "TAG_EVENT_TIME",
    8192: "TAG_BINARY",
    8193: "TAG_PAYLOAD",
    8194: "TAG_ENCRYPT_B64",
    8195: "TAG_TUNNEL_KEY",
    8196: "TAG_CHUNK_DATA",
  }

  _NAMES_TO_VALUES = {
    "TAG_STRING": 0,
    "TAG_FROM": 1,
    "TAG_TO": 2,
    "TAG_APP": 3,
    "TAG_SID": 4,
    "TAG_ACTION": 5,
    "TAG_DEVICENAME": 6,
    "TAG_DEVICEMAC": 7,
    "TAG_USERNAME": 8,
    "TAG_PASSWORD": 9,
    "TAG_LOCALIP": 10,
    "TAG_VERSION": 11,
    "TAG_ACTION_RESULT": 12,
    "TAG_URL": 13,
    "TAG_IP": 14,
    "TAG_PORT": 15,
    "TAG_ID8": 16,
    "TAG_IP_STUNT1": 17,
    "TAG_IP_STUNT2": 18,
    "TAG_IP_RELAY": 19,
    "TAG_PORT_HTTP": 20,
    "TAG_PORT_HTTPS": 21,
    "TAG_CAPABILITY": 22,
    "TAG_ACCESSKEY": 23,
    "TAG_PORT_LIVEVIEW": 24,
    "TAG_PORT_PLAYBACK": 25,
    "TAG_PROXY": 26,
    "TAG_REGISTER_STATUS": 27,
    "TAG_PEER_ID8": 28,
    "TAG_SYSTEM_VERSION": 29,
    "TAG_RELAY_CTRL_PORT": 30,
    "TAG_RELAY_DATA_PORT": 31,
    "TAG_DEVICE_EXT_IP": 32,
    "TAG_EVENT_SRC_IP": 38,
    "TAG_EVENT_DST_IP": 39,
    "TAG_CHUNK_TYPE": 40,
    "TAG_INTEGER": 4096,
    "TAG_TID": 4097,
    "TAG_STATUS": 4098,
    "TAG_ERR": 4099,
    "TAG_EVENT_ID": 4100,
    "TAG_CHUNK_NUMBER": 4101,
    "TAG_EVENT_TIME": 4352,
    "TAG_BINARY": 8192,
    "TAG_PAYLOAD": 8193,
    "TAG_ENCRYPT_B64": 8194,
    "TAG_TUNNEL_KEY": 8195,
    "TAG_CHUNK_DATA": 8196,
  }

class EventSeverity(object):
  """
   Bit-wise Severity Setting to facilitate the event filtering
  *
  """
  EVENT = 6
  ALARM = 1

  _VALUES_TO_NAMES = {
    6: "EVENT",
    1: "ALARM",
  }

  _NAMES_TO_VALUES = {
    "EVENT": 6,
    "ALARM": 1,
  }

class LogLevel(object):
  FATAL = 1
  ERROR = 2
  WARN = 3
  INFO = 4
  DEBUG = 5

  _VALUES_TO_NAMES = {
    1: "FATAL",
    2: "ERROR",
    3: "WARN",
    4: "INFO",
    5: "DEBUG",
  }

  _NAMES_TO_VALUES = {
    "FATAL": 1,
    "ERROR": 2,
    "WARN": 3,
    "INFO": 4,
    "DEBUG": 5,
  }

class ServiceId(object):
  SOCIAL = 1

  _VALUES_TO_NAMES = {
    1: "SOCIAL",
  }

  _NAMES_TO_VALUES = {
    "SOCIAL": 1,
  }


class SharedStruct(object):
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.key = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SharedStruct')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.I32, 1)
      oprot.writeI32(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessToken(object):
  """
    Basic access token
    It is used as authorization code and user's access token
  *

  Attributes:
   - token
   - expireTime
   - sourceIp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.I64, 'expireTime', None, None, ), # 2
    (3, TType.STRING, 'sourceIp', None, None, ), # 3
  )

  def __init__(self, token=None, expireTime=None, sourceIp=None,):
    self.token = token
    self.expireTime = expireTime
    self.sourceIp = sourceIp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.expireTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sourceIp = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessToken')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.expireTime is not None:
      oprot.writeFieldBegin('expireTime', TType.I64, 2)
      oprot.writeI64(self.expireTime)
      oprot.writeFieldEnd()
    if self.sourceIp is not None:
      oprot.writeFieldBegin('sourceIp', TType.STRING, 3)
      oprot.writeString(self.sourceIp.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceId(object):
  """
    Basic device Id information
  *

  Attributes:
   - deviceMac
   - mydlinkId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceMac', None, None, ), # 1
    (2, TType.STRING, 'mydlinkId', None, None, ), # 2
  )

  def __init__(self, deviceMac=None, mydlinkId=None,):
    self.deviceMac = deviceMac
    self.mydlinkId = mydlinkId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceMac = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mydlinkId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceId')
    if self.deviceMac is not None:
      oprot.writeFieldBegin('deviceMac', TType.STRING, 1)
      oprot.writeString(self.deviceMac.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.mydlinkId is not None:
      oprot.writeFieldBegin('mydlinkId', TType.STRING, 2)
      oprot.writeString(self.mydlinkId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User(object):
  """
    Basic user information
  *

  Attributes:
   - userId
   - userName
   - email
   - password
   - firstName
   - lastName
   - confirmed
   - emailNotify
   - phone
   - gender
   - birthYear
   - birthMonth
   - birthDay
   - address1
   - address2
   - city
   - state
   - zipCode
   - country
   - language
   - userToken
   - sourceIp
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
    (2, TType.STRING, 'userName', None, None, ), # 2
    (3, TType.STRING, 'email', None, None, ), # 3
    (4, TType.STRING, 'password', None, None, ), # 4
    (5, TType.STRING, 'firstName', None, None, ), # 5
    (6, TType.STRING, 'lastName', None, None, ), # 6
    (7, TType.BOOL, 'confirmed', None, False, ), # 7
    (8, TType.BOOL, 'emailNotify', None, False, ), # 8
    (9, TType.STRING, 'phone', None, None, ), # 9
    (10, TType.I16, 'gender', None, -1, ), # 10
    (11, TType.I16, 'birthYear', None, None, ), # 11
    (12, TType.I16, 'birthMonth', None, None, ), # 12
    (13, TType.I16, 'birthDay', None, None, ), # 13
    (14, TType.STRING, 'address1', None, None, ), # 14
    (15, TType.STRING, 'address2', None, None, ), # 15
    (16, TType.STRING, 'city', None, None, ), # 16
    (17, TType.STRING, 'state', None, None, ), # 17
    (18, TType.STRING, 'zipCode', None, None, ), # 18
    (19, TType.STRING, 'country', None, None, ), # 19
    (20, TType.STRING, 'language', None, None, ), # 20
    (21, TType.STRUCT, 'userToken', (AccessToken, AccessToken.thrift_spec), None, ), # 21
    (22, TType.STRING, 'sourceIp', None, None, ), # 22
  )

  def __init__(self, userId=None, userName=None, email=None, password=None, firstName=None, lastName=None, confirmed=thrift_spec[7][4], emailNotify=thrift_spec[8][4], phone=None, gender=thrift_spec[10][4], birthYear=None, birthMonth=None, birthDay=None, address1=None, address2=None, city=None, state=None, zipCode=None, country=None, language=None, userToken=None, sourceIp=None,):
    self.userId = userId
    self.userName = userName
    self.email = email
    self.password = password
    self.firstName = firstName
    self.lastName = lastName
    self.confirmed = confirmed
    self.emailNotify = emailNotify
    self.phone = phone
    self.gender = gender
    self.birthYear = birthYear
    self.birthMonth = birthMonth
    self.birthDay = birthDay
    self.address1 = address1
    self.address2 = address2
    self.city = city
    self.state = state
    self.zipCode = zipCode
    self.country = country
    self.language = language
    self.userToken = userToken
    self.sourceIp = sourceIp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.password = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.firstName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.lastName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.confirmed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.emailNotify = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.phone = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.gender = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.birthYear = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.birthMonth = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.birthDay = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.address1 = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.address2 = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.city = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.state = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.zipCode = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRING:
          self.country = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.language = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.userToken = AccessToken()
          self.userToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.sourceIp = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 2)
      oprot.writeString(self.userName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 3)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 4)
      oprot.writeString(self.password.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.firstName is not None:
      oprot.writeFieldBegin('firstName', TType.STRING, 5)
      oprot.writeString(self.firstName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.lastName is not None:
      oprot.writeFieldBegin('lastName', TType.STRING, 6)
      oprot.writeString(self.lastName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.confirmed is not None:
      oprot.writeFieldBegin('confirmed', TType.BOOL, 7)
      oprot.writeBool(self.confirmed)
      oprot.writeFieldEnd()
    if self.emailNotify is not None:
      oprot.writeFieldBegin('emailNotify', TType.BOOL, 8)
      oprot.writeBool(self.emailNotify)
      oprot.writeFieldEnd()
    if self.phone is not None:
      oprot.writeFieldBegin('phone', TType.STRING, 9)
      oprot.writeString(self.phone.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.gender is not None:
      oprot.writeFieldBegin('gender', TType.I16, 10)
      oprot.writeI16(self.gender)
      oprot.writeFieldEnd()
    if self.birthYear is not None:
      oprot.writeFieldBegin('birthYear', TType.I16, 11)
      oprot.writeI16(self.birthYear)
      oprot.writeFieldEnd()
    if self.birthMonth is not None:
      oprot.writeFieldBegin('birthMonth', TType.I16, 12)
      oprot.writeI16(self.birthMonth)
      oprot.writeFieldEnd()
    if self.birthDay is not None:
      oprot.writeFieldBegin('birthDay', TType.I16, 13)
      oprot.writeI16(self.birthDay)
      oprot.writeFieldEnd()
    if self.address1 is not None:
      oprot.writeFieldBegin('address1', TType.STRING, 14)
      oprot.writeString(self.address1.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.address2 is not None:
      oprot.writeFieldBegin('address2', TType.STRING, 15)
      oprot.writeString(self.address2.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.city is not None:
      oprot.writeFieldBegin('city', TType.STRING, 16)
      oprot.writeString(self.city.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 17)
      oprot.writeString(self.state.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.zipCode is not None:
      oprot.writeFieldBegin('zipCode', TType.STRING, 18)
      oprot.writeString(self.zipCode.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.country is not None:
      oprot.writeFieldBegin('country', TType.STRING, 19)
      oprot.writeString(self.country.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.language is not None:
      oprot.writeFieldBegin('language', TType.STRING, 20)
      oprot.writeString(self.language.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userToken is not None:
      oprot.writeFieldBegin('userToken', TType.STRUCT, 21)
      self.userToken.write(oprot)
      oprot.writeFieldEnd()
    if self.sourceIp is not None:
      oprot.writeFieldBegin('sourceIp', TType.STRING, 22)
      oprot.writeString(self.sourceIp.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Application(object):
  """
    Basic application information
  *

  Attributes:
   - appId
   - credential
   - remark
   - type
   - appToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'appId', None, None, ), # 1
    (2, TType.STRING, 'credential', None, None, ), # 2
    (3, TType.STRING, 'remark', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 5
  )

  def __init__(self, appId=None, credential=None, remark=None, type=None, appToken=None,):
    self.appId = appId
    self.credential = credential
    self.remark = remark
    self.type = type
    self.appToken = appToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.appId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.credential = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.remark = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Application')
    if self.appId is not None:
      oprot.writeFieldBegin('appId', TType.STRING, 1)
      oprot.writeString(self.appId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.credential is not None:
      oprot.writeFieldBegin('credential', TType.STRING, 2)
      oprot.writeString(self.credential.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.remark is not None:
      oprot.writeFieldBegin('remark', TType.STRING, 3)
      oprot.writeString(self.remark.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 5)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthResponse(object):
  """
    Authorization response from Nexus
  *

  Attributes:
   - isGranted
   - authCode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isGranted', None, None, ), # 1
    (2, TType.STRUCT, 'authCode', (AccessToken, AccessToken.thrift_spec), None, ), # 2
  )

  def __init__(self, isGranted=None, authCode=None,):
    self.isGranted = isGranted
    self.authCode = authCode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isGranted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authCode = AccessToken()
          self.authCode.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthResponse')
    if self.isGranted is not None:
      oprot.writeFieldBegin('isGranted', TType.BOOL, 1)
      oprot.writeBool(self.isGranted)
      oprot.writeFieldEnd()
    if self.authCode is not None:
      oprot.writeFieldBegin('authCode', TType.STRUCT, 2)
      self.authCode.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AppAuthenInfo(object):
  """
    Application authentication information
    It is used to get user's access token after pass user's authentication
  *

  Attributes:
   - appId
   - reqTime
   - uri
   - signature
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'appId', None, None, ), # 1
    (2, TType.STRING, 'reqTime', None, None, ), # 2
    (3, TType.STRING, 'uri', None, None, ), # 3
    (4, TType.STRING, 'signature', None, None, ), # 4
  )

  def __init__(self, appId=None, reqTime=None, uri=None, signature=None,):
    self.appId = appId
    self.reqTime = reqTime
    self.uri = uri
    self.signature = signature

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.appId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.reqTime = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.uri = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.signature = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AppAuthenInfo')
    if self.appId is not None:
      oprot.writeFieldBegin('appId', TType.STRING, 1)
      oprot.writeString(self.appId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.reqTime is not None:
      oprot.writeFieldBegin('reqTime', TType.STRING, 2)
      oprot.writeString(self.reqTime.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 3)
      oprot.writeString(self.uri.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.signature is not None:
      oprot.writeFieldBegin('signature', TType.STRING, 4)
      oprot.writeString(self.signature.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Location(object):
  """
    Basic location information with longitude/latitude
  *

  Attributes:
   - longitude
   - latitude
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'longitude', None, None, ), # 1
    (2, TType.DOUBLE, 'latitude', None, None, ), # 2
  )

  def __init__(self, longitude=None, latitude=None,):
    self.longitude = longitude
    self.latitude = latitude

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.longitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.latitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Location')
    if self.longitude is not None:
      oprot.writeFieldBegin('longitude', TType.DOUBLE, 1)
      oprot.writeDouble(self.longitude)
      oprot.writeFieldEnd()
    if self.latitude is not None:
      oprot.writeFieldBegin('latitude', TType.DOUBLE, 2)
      oprot.writeDouble(self.latitude)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Device(object):
  """
    Basic device information
  *

  Attributes:
   - deviceSId
   - deviceId
   - linkUp
   - ownerId
   - devName
   - devModel
   - devType
   - location
   - publicUrl
   - address
   - sldName
   - accessKey
   - localAccessUrl
   - directAccessUrl
   - homeSite
   - visits
   - proxySite
   - devVersion
   - notification
   - owner
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'deviceSId', None, None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'linkUp', None, None, ), # 3
    (4, TType.I32, 'ownerId', None, None, ), # 4
    (5, TType.STRING, 'devName', None, None, ), # 5
    (6, TType.STRING, 'devModel', None, None, ), # 6
    (7, TType.I32, 'devType', None, None, ), # 7
    (8, TType.STRUCT, 'location', (Location, Location.thrift_spec), None, ), # 8
    (9, TType.STRING, 'publicUrl', None, None, ), # 9
    (10, TType.STRING, 'address', None, None, ), # 10
    (11, TType.STRING, 'sldName', None, None, ), # 11
    (12, TType.STRING, 'accessKey', None, None, ), # 12
    (13, TType.STRING, 'localAccessUrl', None, None, ), # 13
    (14, TType.STRING, 'directAccessUrl', None, None, ), # 14
    (15, TType.STRING, 'homeSite', None, None, ), # 15
    (16, TType.I64, 'visits', None, None, ), # 16
    (17, TType.STRING, 'proxySite', None, None, ), # 17
    (18, TType.STRING, 'devVersion', None, None, ), # 18
    (19, TType.I32, 'notification', None, None, ), # 19
    (20, TType.STRING, 'owner', None, None, ), # 20
  )

  def __init__(self, deviceSId=None, deviceId=None, linkUp=None, ownerId=None, devName=None, devModel=None, devType=None, location=None, publicUrl=None, address=None, sldName=None, accessKey=None, localAccessUrl=None, directAccessUrl=None, homeSite=None, visits=None, proxySite=None, devVersion=None, notification=None, owner=None,):
    self.deviceSId = deviceSId
    self.deviceId = deviceId
    self.linkUp = linkUp
    self.ownerId = ownerId
    self.devName = devName
    self.devModel = devModel
    self.devType = devType
    self.location = location
    self.publicUrl = publicUrl
    self.address = address
    self.sldName = sldName
    self.accessKey = accessKey
    self.localAccessUrl = localAccessUrl
    self.directAccessUrl = directAccessUrl
    self.homeSite = homeSite
    self.visits = visits
    self.proxySite = proxySite
    self.devVersion = devVersion
    self.notification = notification
    self.owner = owner

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.deviceSId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.linkUp = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.devName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.devModel = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.devType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.location = Location()
          self.location.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.publicUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.address = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.sldName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.localAccessUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.directAccessUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.homeSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I64:
          self.visits = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.proxySite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.devVersion = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I32:
          self.notification = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.owner = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Device')
    if self.deviceSId is not None:
      oprot.writeFieldBegin('deviceSId', TType.I32, 1)
      oprot.writeI32(self.deviceSId)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.linkUp is not None:
      oprot.writeFieldBegin('linkUp', TType.BOOL, 3)
      oprot.writeBool(self.linkUp)
      oprot.writeFieldEnd()
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 4)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.devName is not None:
      oprot.writeFieldBegin('devName', TType.STRING, 5)
      oprot.writeString(self.devName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.devModel is not None:
      oprot.writeFieldBegin('devModel', TType.STRING, 6)
      oprot.writeString(self.devModel.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.devType is not None:
      oprot.writeFieldBegin('devType', TType.I32, 7)
      oprot.writeI32(self.devType)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRUCT, 8)
      self.location.write(oprot)
      oprot.writeFieldEnd()
    if self.publicUrl is not None:
      oprot.writeFieldBegin('publicUrl', TType.STRING, 9)
      oprot.writeString(self.publicUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.address is not None:
      oprot.writeFieldBegin('address', TType.STRING, 10)
      oprot.writeString(self.address.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.sldName is not None:
      oprot.writeFieldBegin('sldName', TType.STRING, 11)
      oprot.writeString(self.sldName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 12)
      oprot.writeString(self.accessKey.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.localAccessUrl is not None:
      oprot.writeFieldBegin('localAccessUrl', TType.STRING, 13)
      oprot.writeString(self.localAccessUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.directAccessUrl is not None:
      oprot.writeFieldBegin('directAccessUrl', TType.STRING, 14)
      oprot.writeString(self.directAccessUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.homeSite is not None:
      oprot.writeFieldBegin('homeSite', TType.STRING, 15)
      oprot.writeString(self.homeSite.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.visits is not None:
      oprot.writeFieldBegin('visits', TType.I64, 16)
      oprot.writeI64(self.visits)
      oprot.writeFieldEnd()
    if self.proxySite is not None:
      oprot.writeFieldBegin('proxySite', TType.STRING, 17)
      oprot.writeString(self.proxySite.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.devVersion is not None:
      oprot.writeFieldBegin('devVersion', TType.STRING, 18)
      oprot.writeString(self.devVersion.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.notification is not None:
      oprot.writeFieldBegin('notification', TType.I32, 19)
      oprot.writeI32(self.notification)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 20)
      oprot.writeString(self.owner.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceSignInRequest(object):
  """
    Device sign in request sending from SLD to Nexus
  *

  Attributes:
   - deviceId
   - sourceIp
   - homeSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.STRING, 'sourceIp', None, None, ), # 2
    (3, TType.STRING, 'homeSite', None, None, ), # 3
  )

  def __init__(self, deviceId=None, sourceIp=None, homeSite=None,):
    self.deviceId = deviceId
    self.sourceIp = sourceIp
    self.homeSite = homeSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.sourceIp = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.homeSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceSignInRequest')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.sourceIp is not None:
      oprot.writeFieldBegin('sourceIp', TType.STRING, 2)
      oprot.writeString(self.sourceIp.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.homeSite is not None:
      oprot.writeFieldBegin('homeSite', TType.STRING, 3)
      oprot.writeString(self.homeSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceSignInResponse(object):
  """
    DBAgent response to SLD signing in
    returnCode definition: 200----OK,301---redirect,403---forbidden
  *

  Attributes:
   - returnCode
   - deviceId
   - portalUrl
   - siteUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'returnCode', None, None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.STRING, 'portalUrl', None, None, ), # 3
    (4, TType.STRING, 'siteUrl', None, None, ), # 4
  )

  def __init__(self, returnCode=None, deviceId=None, portalUrl=None, siteUrl=None,):
    self.returnCode = returnCode
    self.deviceId = deviceId
    self.portalUrl = portalUrl
    self.siteUrl = siteUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.returnCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.portalUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.siteUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceSignInResponse')
    if self.returnCode is not None:
      oprot.writeFieldBegin('returnCode', TType.I32, 1)
      oprot.writeI32(self.returnCode)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.portalUrl is not None:
      oprot.writeFieldBegin('portalUrl', TType.STRING, 3)
      oprot.writeString(self.portalUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.siteUrl is not None:
      oprot.writeFieldBegin('siteUrl', TType.STRING, 4)
      oprot.writeString(self.siteUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceConnRequest(object):
  """
  Basic unit of Connect Request sent from NBS to Sld via Nexus
  @param deviceId,           the mac address and mydlinkID of the target device
  @param clientId,          the identifier of the client for the logging and trace
  @param relayEntry,        the uri to pass to CA/DA for the control entry of connection establishment,
                             figured out by Nexus,send to Sld and response to NBS
  @param sessionId,         the identifier of the streaming connection generated by Nexus,
                             send to Sld and response to NBS

  @recordingMeta: {'sessionId': 'eaa53223-8682-44f8-b793-f69bf149f144-0',
    (JSON)          'apiUrl': 'http://api.myslink.com/nbs',
                    'storageType': 'local'
  				 }

  Attributes:
   - deviceId
   - clientId
   - serviceType
   - relayEntry
   - sessionId
   - recordingMeta
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.STRING, 'clientId', None, None, ), # 2
    (3, TType.I32, 'serviceType', None, None, ), # 3
    (4, TType.STRING, 'relayEntry', None, None, ), # 4
    (5, TType.STRING, 'sessionId', None, None, ), # 5
    (6, TType.STRING, 'recordingMeta', None, None, ), # 6
  )

  def __init__(self, deviceId=None, clientId=None, serviceType=None, relayEntry=None, sessionId=None, recordingMeta=None,):
    self.deviceId = deviceId
    self.clientId = clientId
    self.serviceType = serviceType
    self.relayEntry = relayEntry
    self.sessionId = sessionId
    self.recordingMeta = recordingMeta

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.serviceType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.relayEntry = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.recordingMeta = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceConnRequest')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 2)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.serviceType is not None:
      oprot.writeFieldBegin('serviceType', TType.I32, 3)
      oprot.writeI32(self.serviceType)
      oprot.writeFieldEnd()
    if self.relayEntry is not None:
      oprot.writeFieldBegin('relayEntry', TType.STRING, 4)
      oprot.writeString(self.relayEntry.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 5)
      oprot.writeString(self.sessionId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.recordingMeta is not None:
      oprot.writeFieldBegin('recordingMeta', TType.STRING, 6)
      oprot.writeString(self.recordingMeta.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceConnResponse(object):
  """
  Basic unit of Connect Response returned from Nexus to NBS
  @param device,             the mac address of the target device
  @param relayEntry,        the uri to pass to CA/DA for the control entry of connection establishment
  @param sessionId,         the identifier of the streaming connection

  Attributes:
   - deviceId
   - relayEntry
   - sessionId
   - localAccessUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.STRING, 'relayEntry', None, None, ), # 2
    (3, TType.STRING, 'sessionId', None, None, ), # 3
    (4, TType.STRING, 'localAccessUrl', None, None, ), # 4
  )

  def __init__(self, deviceId=None, relayEntry=None, sessionId=None, localAccessUrl=None,):
    self.deviceId = deviceId
    self.relayEntry = relayEntry
    self.sessionId = sessionId
    self.localAccessUrl = localAccessUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.relayEntry = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.localAccessUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceConnResponse')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.relayEntry is not None:
      oprot.writeFieldBegin('relayEntry', TType.STRING, 2)
      oprot.writeString(self.relayEntry.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 3)
      oprot.writeString(self.sessionId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.localAccessUrl is not None:
      oprot.writeFieldBegin('localAccessUrl', TType.STRING, 4)
      oprot.writeString(self.localAccessUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceEvent(object):
  """
  Attributes:
   - deviceId
   - action
   - sldName
   - localAccessUrl
   - accessKey
   - directAccessUrl
   - sessionId
   - serviceType
   - connType
   - devName
   - devVersion
   - bootstrapStatus
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.I32, 'action', None, None, ), # 2
    (3, TType.STRING, 'sldName', None, None, ), # 3
    (4, TType.STRING, 'localAccessUrl', None, None, ), # 4
    (5, TType.STRING, 'accessKey', None, None, ), # 5
    (6, TType.STRING, 'directAccessUrl', None, None, ), # 6
    (7, TType.STRING, 'sessionId', None, None, ), # 7
    (8, TType.I32, 'serviceType', None, None, ), # 8
    (9, TType.I32, 'connType', None, None, ), # 9
    (10, TType.STRING, 'devName', None, None, ), # 10
    (11, TType.STRING, 'devVersion', None, None, ), # 11
    (12, TType.I32, 'bootstrapStatus', None, None, ), # 12
  )

  def __init__(self, deviceId=None, action=None, sldName=None, localAccessUrl=None, accessKey=None, directAccessUrl=None, sessionId=None, serviceType=None, connType=None, devName=None, devVersion=None, bootstrapStatus=None,):
    self.deviceId = deviceId
    self.action = action
    self.sldName = sldName
    self.localAccessUrl = localAccessUrl
    self.accessKey = accessKey
    self.directAccessUrl = directAccessUrl
    self.sessionId = sessionId
    self.serviceType = serviceType
    self.connType = connType
    self.devName = devName
    self.devVersion = devVersion
    self.bootstrapStatus = bootstrapStatus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sldName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.localAccessUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.directAccessUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.serviceType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.connType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.devName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.devVersion = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.bootstrapStatus = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceEvent')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 2)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.sldName is not None:
      oprot.writeFieldBegin('sldName', TType.STRING, 3)
      oprot.writeString(self.sldName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.localAccessUrl is not None:
      oprot.writeFieldBegin('localAccessUrl', TType.STRING, 4)
      oprot.writeString(self.localAccessUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 5)
      oprot.writeString(self.accessKey.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.directAccessUrl is not None:
      oprot.writeFieldBegin('directAccessUrl', TType.STRING, 6)
      oprot.writeString(self.directAccessUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 7)
      oprot.writeString(self.sessionId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.serviceType is not None:
      oprot.writeFieldBegin('serviceType', TType.I32, 8)
      oprot.writeI32(self.serviceType)
      oprot.writeFieldEnd()
    if self.connType is not None:
      oprot.writeFieldBegin('connType', TType.I32, 9)
      oprot.writeI32(self.connType)
      oprot.writeFieldEnd()
    if self.devName is not None:
      oprot.writeFieldBegin('devName', TType.STRING, 10)
      oprot.writeString(self.devName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.devVersion is not None:
      oprot.writeFieldBegin('devVersion', TType.STRING, 11)
      oprot.writeString(self.devVersion.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.bootstrapStatus is not None:
      oprot.writeFieldBegin('bootstrapStatus', TType.I32, 12)
      oprot.writeI32(self.bootstrapStatus)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CmdToSld(object):
  """
  Attributes:
   - action
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, deviceId=None,):
    self.action = action
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CmdToSld')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryId(object):
  """
     Media Service Interface:
     The relay monitor process will keep polling the media servers via the remote gearmand so get the latest system loading.
         GetMsInfo(QueryId) The queryId is for the logging in the media servers to track which site is associated with it.
     The NBS will ask for the media service candidate via the local gearmand to the relay monitor process.
  *

  Attributes:
   - id
   - remark
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'remark', None, None, ), # 2
  )

  def __init__(self, id=None, remark=None,):
    self.id = id
    self.remark = remark

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.remark = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryId')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.remark is not None:
      oprot.writeFieldBegin('remark', TType.STRING, 2)
      oprot.writeString(self.remark.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MsInfo(object):
  """
    Media Server (Relay) SysInfo
  *

  Attributes:
   - control_path
   - data_path
   - current_connections
   - maximal_concurrency
   - error_count
   - availability_index
   - system_loading
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'control_path', None, None, ), # 1
    (2, TType.STRING, 'data_path', None, None, ), # 2
    (3, TType.I32, 'current_connections', None, None, ), # 3
    (4, TType.I32, 'maximal_concurrency', None, None, ), # 4
    (5, TType.I32, 'error_count', None, None, ), # 5
    (6, TType.I32, 'availability_index', None, None, ), # 6
    (7, TType.STRING, 'system_loading', None, None, ), # 7
  )

  def __init__(self, control_path=None, data_path=None, current_connections=None, maximal_concurrency=None, error_count=None, availability_index=None, system_loading=None,):
    self.control_path = control_path
    self.data_path = data_path
    self.current_connections = current_connections
    self.maximal_concurrency = maximal_concurrency
    self.error_count = error_count
    self.availability_index = availability_index
    self.system_loading = system_loading

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.control_path = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data_path = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.current_connections = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maximal_concurrency = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.error_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.availability_index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.system_loading = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MsInfo')
    if self.control_path is not None:
      oprot.writeFieldBegin('control_path', TType.STRING, 1)
      oprot.writeString(self.control_path.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.data_path is not None:
      oprot.writeFieldBegin('data_path', TType.STRING, 2)
      oprot.writeString(self.data_path.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.current_connections is not None:
      oprot.writeFieldBegin('current_connections', TType.I32, 3)
      oprot.writeI32(self.current_connections)
      oprot.writeFieldEnd()
    if self.maximal_concurrency is not None:
      oprot.writeFieldBegin('maximal_concurrency', TType.I32, 4)
      oprot.writeI32(self.maximal_concurrency)
      oprot.writeFieldEnd()
    if self.error_count is not None:
      oprot.writeFieldBegin('error_count', TType.I32, 5)
      oprot.writeI32(self.error_count)
      oprot.writeFieldEnd()
    if self.availability_index is not None:
      oprot.writeFieldBegin('availability_index', TType.I32, 6)
      oprot.writeI32(self.availability_index)
      oprot.writeFieldEnd()
    if self.system_loading is not None:
      oprot.writeFieldBegin('system_loading', TType.STRING, 7)
      oprot.writeString(self.system_loading.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MsSel(object):
  """
  Attributes:
   - control_path
   - data_path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'control_path', None, None, ), # 1
    (2, TType.STRING, 'data_path', None, None, ), # 2
  )

  def __init__(self, control_path=None, data_path=None,):
    self.control_path = control_path
    self.data_path = data_path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.control_path = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data_path = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MsSel')
    if self.control_path is not None:
      oprot.writeFieldBegin('control_path', TType.STRING, 1)
      oprot.writeString(self.control_path.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.data_path is not None:
      oprot.writeFieldBegin('data_path', TType.STRING, 2)
      oprot.writeString(self.data_path.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LogEvent(object):
  """
    Basic logging information sent to Nexus
  *

  Attributes:
   - issuerId
   - loggerName
   - level
   - filename
   - lineno
   - funcname
   - renderedMsg
   - loggingtime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'issuerId', None, None, ), # 1
    (2, TType.STRING, 'loggerName', None, None, ), # 2
    (3, TType.I32, 'level', None, None, ), # 3
    (4, TType.STRING, 'filename', None, None, ), # 4
    (5, TType.I32, 'lineno', None, None, ), # 5
    (6, TType.STRING, 'funcname', None, None, ), # 6
    (7, TType.STRING, 'renderedMsg', None, None, ), # 7
    (8, TType.I64, 'loggingtime', None, None, ), # 8
  )

  def __init__(self, issuerId=None, loggerName=None, level=None, filename=None, lineno=None, funcname=None, renderedMsg=None, loggingtime=None,):
    self.issuerId = issuerId
    self.loggerName = loggerName
    self.level = level
    self.filename = filename
    self.lineno = lineno
    self.funcname = funcname
    self.renderedMsg = renderedMsg
    self.loggingtime = loggingtime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.issuerId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.loggerName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filename = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lineno = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.funcname = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.renderedMsg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.loggingtime = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LogEvent')
    if self.issuerId is not None:
      oprot.writeFieldBegin('issuerId', TType.STRING, 1)
      oprot.writeString(self.issuerId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.loggerName is not None:
      oprot.writeFieldBegin('loggerName', TType.STRING, 2)
      oprot.writeString(self.loggerName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 3)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.filename is not None:
      oprot.writeFieldBegin('filename', TType.STRING, 4)
      oprot.writeString(self.filename.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.lineno is not None:
      oprot.writeFieldBegin('lineno', TType.I32, 5)
      oprot.writeI32(self.lineno)
      oprot.writeFieldEnd()
    if self.funcname is not None:
      oprot.writeFieldBegin('funcname', TType.STRING, 6)
      oprot.writeString(self.funcname.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.renderedMsg is not None:
      oprot.writeFieldBegin('renderedMsg', TType.STRING, 7)
      oprot.writeString(self.renderedMsg.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.loggingtime is not None:
      oprot.writeFieldBegin('loggingtime', TType.I64, 8)
      oprot.writeI64(self.loggingtime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GroupTitle(object):
  """
  Attributes:
   - groupId
   - groupName
   - groupNumber
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'groupId', None, None, ), # 1
    (2, TType.STRING, 'groupName', None, None, ), # 2
    (3, TType.I32, 'groupNumber', None, None, ), # 3
  )

  def __init__(self, groupId=None, groupName=None, groupNumber=None,):
    self.groupId = groupId
    self.groupName = groupName
    self.groupNumber = groupNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.groupId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.groupNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GroupTitle')
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.I32, 1)
      oprot.writeI32(self.groupId)
      oprot.writeFieldEnd()
    if self.groupName is not None:
      oprot.writeFieldBegin('groupName', TType.STRING, 2)
      oprot.writeString(self.groupName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.groupNumber is not None:
      oprot.writeFieldBegin('groupNumber', TType.I32, 3)
      oprot.writeI32(self.groupNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Record(object):
  """
    Record details from MdRecording columnfamily
  *

  Attributes:
   - deviceId
   - recordTime
   - fileUrl
   - trigger
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.I64, 'recordTime', None, None, ), # 2
    (3, TType.STRING, 'fileUrl', None, None, ), # 3
    (4, TType.STRING, 'trigger', None, None, ), # 4
    (5, TType.STRING, 'description', None, None, ), # 5
  )

  def __init__(self, deviceId=None, recordTime=None, fileUrl=None, trigger=None, description=None,):
    self.deviceId = deviceId
    self.recordTime = recordTime
    self.fileUrl = fileUrl
    self.trigger = trigger
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.recordTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.fileUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.trigger = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.description = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Record')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.recordTime is not None:
      oprot.writeFieldBegin('recordTime', TType.I64, 2)
      oprot.writeI64(self.recordTime)
      oprot.writeFieldEnd()
    if self.fileUrl is not None:
      oprot.writeFieldBegin('fileUrl', TType.STRING, 3)
      oprot.writeString(self.fileUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRING, 4)
      oprot.writeString(self.trigger.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 5)
      oprot.writeString(self.description.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceEventNotification(object):
  """
  for integration with v2 event logging*

  Attributes:
   - deviceSId
   - params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'deviceSId', None, None, ), # 1
    (2, TType.MAP, 'params', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, deviceSId=None, params=None,):
    self.deviceSId = deviceSId
    self.params = params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.deviceSId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.params = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readString().decode('utf-8')
            _val6 = iprot.readString().decode('utf-8')
            self.params[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceEventNotification')
    if self.deviceSId is not None:
      oprot.writeFieldBegin('deviceSId', TType.I32, 1)
      oprot.writeI32(self.deviceSId)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.params))
      for kiter7,viter8 in self.params.items():
        oprot.writeString(kiter7.encode('utf-8'))
        oprot.writeString(viter8.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceSharing(object):
  """
  Attributes:
   - email
   - privilege
   - sharingStatus
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'email', None, None, ), # 1
    (2, TType.I32, 'privilege', None, None, ), # 2
    (3, TType.I32, 'sharingStatus', None, None, ), # 3
  )

  def __init__(self, email=None, privilege=None, sharingStatus=None,):
    self.email = email
    self.privilege = privilege
    self.sharingStatus = sharingStatus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.sharingStatus = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceSharing')
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 1)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 2)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.sharingStatus is not None:
      oprot.writeFieldBegin('sharingStatus', TType.I32, 3)
      oprot.writeI32(self.sharingStatus)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SharedDevice(object):
  """
  Attributes:
   - deviceId
   - devName
   - ownerEmail
   - ownerDisplayName
   - privilege
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.STRING, 'devName', None, None, ), # 2
    (3, TType.STRING, 'ownerEmail', None, None, ), # 3
    (4, TType.STRING, 'ownerDisplayName', None, None, ), # 4
    (5, TType.I32, 'privilege', None, None, ), # 5
  )

  def __init__(self, deviceId=None, devName=None, ownerEmail=None, ownerDisplayName=None, privilege=None,):
    self.deviceId = deviceId
    self.devName = devName
    self.ownerEmail = ownerEmail
    self.ownerDisplayName = ownerDisplayName
    self.privilege = privilege

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.devName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ownerEmail = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ownerDisplayName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SharedDevice')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.devName is not None:
      oprot.writeFieldBegin('devName', TType.STRING, 2)
      oprot.writeString(self.devName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.ownerEmail is not None:
      oprot.writeFieldBegin('ownerEmail', TType.STRING, 3)
      oprot.writeString(self.ownerEmail.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.ownerDisplayName is not None:
      oprot.writeFieldBegin('ownerDisplayName', TType.STRING, 4)
      oprot.writeString(self.ownerDisplayName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 5)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Contact(object):
  """
  Attributes:
   - email
   - nickName
   - services
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'email', None, None, ), # 1
    (2, TType.STRING, 'nickName', None, None, ), # 2
    (3, TType.LIST, 'services', (TType.I32,None), None, ), # 3
  )

  def __init__(self, email=None, nickName=None, services=None,):
    self.email = email
    self.nickName = nickName
    self.services = services

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.nickName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.services = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readI32();
            self.services.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Contact')
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 1)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.nickName is not None:
      oprot.writeFieldBegin('nickName', TType.STRING, 2)
      oprot.writeString(self.nickName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.services is not None:
      oprot.writeFieldBegin('services', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.services))
      for iter15 in self.services:
        oprot.writeI32(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MobileToken(object):
  """
  Attributes:
   - token
   - displayName
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'displayName', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, token=None, displayName=None, type=None,):
    self.token = token
    self.displayName = displayName
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.displayName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MobileToken')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 2)
      oprot.writeString(self.displayName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOperationException(Exception):
  """
  exceptions

  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     400, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOperationException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidAuthCodeException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     401, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidAuthCodeException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidAccessTokenException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     402, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidAccessTokenException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidDeviceException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     403, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidDeviceException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOwnerException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     404, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOwnerException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidUserException(Exception):
  """
  Attributes:
   - fail_count
   - isMaxError
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'fail_count', None, None, ), # 1
    (2, TType.BOOL, 'isMaxError', None, None, ), # 2
  )

  def __init__(self, fail_count=None, isMaxError=None,):
    self.fail_count = fail_count
    self.isMaxError = isMaxError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.fail_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isMaxError = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidUserException')
    if self.fail_count is not None:
      oprot.writeFieldBegin('fail_count', TType.I32, 1)
      oprot.writeI32(self.fail_count)
      oprot.writeFieldEnd()
    if self.isMaxError is not None:
      oprot.writeFieldBegin('isMaxError', TType.BOOL, 2)
      oprot.writeBool(self.isMaxError)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidAppException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     406, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidAppException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownUserException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     407, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownUserException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownAppException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     408, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownAppException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExistedEntityException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     409, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExistedEntityException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncorrectSiteException(Exception):
  """
  Attributes:
   - id
   - correctUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     410, ), # 1
    (2, TType.STRING, 'correctUrl', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], correctUrl=None,):
    self.id = id
    self.correctUrl = correctUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.correctUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncorrectSiteException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.correctUrl is not None:
      oprot.writeFieldBegin('correctUrl', TType.STRING, 2)
      oprot.writeString(self.correctUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidTimestampException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     411, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidTimestampException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DuplicateTimestampException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     412, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DuplicateTimestampException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnavailableException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     413, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnavailableException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimedOutException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     414, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimedOutException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidParamException(Exception):
  """
  Attributes:
   - id
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None,     415, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, id=thrift_spec[1][4], msg=None,):
    self.id = id
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidParamException')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
