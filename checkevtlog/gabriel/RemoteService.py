#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import gabriel.SharedService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(gabriel.SharedService.Iface):
  """
  ***************************************************************************
    Services For Cross-site
  ***************************************************************************
  """
  def deviceSignIn(self, device, fromSite):
    """
    Parameters:
     - device
     - fromSite
    """
    pass

  def deviceEventReport(self, devEvent, fromSite):
    """
    Parameters:
     - devEvent
     - fromSite
    """
    pass

  def deviceConn(self, req, fromSite):
    """
    Parameters:
     - req
     - fromSite
    """
    pass

  def bindRemoteDevice(self, deviceId, accessKey, fromSite):
    """
    Parameters:
     - deviceId
     - accessKey
     - fromSite
    """
    pass

  def getRemoteDevice(self, deviceId, fromSite):
    """
    Parameters:
     - deviceId
     - fromSite
    """
    pass

  def setRemoteDevice(self, device, fromSite):
    """
    Parameters:
     - device
     - fromSite
    """
    pass

  def changeRemoteUserSite(self, email, changeToSite, fromSite):
    """
    Parameters:
     - email
     - changeToSite
     - fromSite
    """
    pass

  def getRemoteUser(self, email, fromSite):
    """
    Parameters:
     - email
     - fromSite
    """
    pass


class Client(gabriel.SharedService.Client, Iface):
  """
  ***************************************************************************
    Services For Cross-site
  ***************************************************************************
  """
  def __init__(self, iprot, oprot=None):
    gabriel.SharedService.Client.__init__(self, iprot, oprot)

  def deviceSignIn(self, device, fromSite):
    """
    Parameters:
     - device
     - fromSite
    """
    self.send_deviceSignIn(device, fromSite)
    return self.recv_deviceSignIn()

  def send_deviceSignIn(self, device, fromSite):
    self._oprot.writeMessageBegin('deviceSignIn', TMessageType.CALL, self._seqid)
    args = deviceSignIn_args()
    args.device = device
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deviceSignIn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deviceSignIn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deviceSignIn failed: unknown result");

  def deviceEventReport(self, devEvent, fromSite):
    """
    Parameters:
     - devEvent
     - fromSite
    """
    self.send_deviceEventReport(devEvent, fromSite)
    self.recv_deviceEventReport()

  def send_deviceEventReport(self, devEvent, fromSite):
    self._oprot.writeMessageBegin('deviceEventReport', TMessageType.CALL, self._seqid)
    args = deviceEventReport_args()
    args.devEvent = devEvent
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deviceEventReport(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deviceEventReport_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def deviceConn(self, req, fromSite):
    """
    Parameters:
     - req
     - fromSite
    """
    self.send_deviceConn(req, fromSite)
    return self.recv_deviceConn()

  def send_deviceConn(self, req, fromSite):
    self._oprot.writeMessageBegin('deviceConn', TMessageType.CALL, self._seqid)
    args = deviceConn_args()
    args.req = req
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deviceConn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deviceConn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deviceConn failed: unknown result");

  def bindRemoteDevice(self, deviceId, accessKey, fromSite):
    """
    Parameters:
     - deviceId
     - accessKey
     - fromSite
    """
    self.send_bindRemoteDevice(deviceId, accessKey, fromSite)
    return self.recv_bindRemoteDevice()

  def send_bindRemoteDevice(self, deviceId, accessKey, fromSite):
    self._oprot.writeMessageBegin('bindRemoteDevice', TMessageType.CALL, self._seqid)
    args = bindRemoteDevice_args()
    args.deviceId = deviceId
    args.accessKey = accessKey
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bindRemoteDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = bindRemoteDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bindRemoteDevice failed: unknown result");

  def getRemoteDevice(self, deviceId, fromSite):
    """
    Parameters:
     - deviceId
     - fromSite
    """
    self.send_getRemoteDevice(deviceId, fromSite)
    return self.recv_getRemoteDevice()

  def send_getRemoteDevice(self, deviceId, fromSite):
    self._oprot.writeMessageBegin('getRemoteDevice', TMessageType.CALL, self._seqid)
    args = getRemoteDevice_args()
    args.deviceId = deviceId
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRemoteDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRemoteDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ide is not None:
      raise result.ide
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRemoteDevice failed: unknown result");

  def setRemoteDevice(self, device, fromSite):
    """
    Parameters:
     - device
     - fromSite
    """
    self.send_setRemoteDevice(device, fromSite)
    return self.recv_setRemoteDevice()

  def send_setRemoteDevice(self, device, fromSite):
    self._oprot.writeMessageBegin('setRemoteDevice', TMessageType.CALL, self._seqid)
    args = setRemoteDevice_args()
    args.device = device
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setRemoteDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setRemoteDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ide is not None:
      raise result.ide
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setRemoteDevice failed: unknown result");

  def changeRemoteUserSite(self, email, changeToSite, fromSite):
    """
    Parameters:
     - email
     - changeToSite
     - fromSite
    """
    self.send_changeRemoteUserSite(email, changeToSite, fromSite)
    return self.recv_changeRemoteUserSite()

  def send_changeRemoteUserSite(self, email, changeToSite, fromSite):
    self._oprot.writeMessageBegin('changeRemoteUserSite', TMessageType.CALL, self._seqid)
    args = changeRemoteUserSite_args()
    args.email = email
    args.changeToSite = changeToSite
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_changeRemoteUserSite(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = changeRemoteUserSite_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iue is not None:
      raise result.iue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "changeRemoteUserSite failed: unknown result");

  def getRemoteUser(self, email, fromSite):
    """
    Parameters:
     - email
     - fromSite
    """
    self.send_getRemoteUser(email, fromSite)
    return self.recv_getRemoteUser()

  def send_getRemoteUser(self, email, fromSite):
    self._oprot.writeMessageBegin('getRemoteUser', TMessageType.CALL, self._seqid)
    args = getRemoteUser_args()
    args.email = email
    args.fromSite = fromSite
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRemoteUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRemoteUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iue is not None:
      raise result.iue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRemoteUser failed: unknown result");


class Processor(gabriel.SharedService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    gabriel.SharedService.Processor.__init__(self, handler)
    self._processMap["deviceSignIn"] = Processor.process_deviceSignIn
    self._processMap["deviceEventReport"] = Processor.process_deviceEventReport
    self._processMap["deviceConn"] = Processor.process_deviceConn
    self._processMap["bindRemoteDevice"] = Processor.process_bindRemoteDevice
    self._processMap["getRemoteDevice"] = Processor.process_getRemoteDevice
    self._processMap["setRemoteDevice"] = Processor.process_setRemoteDevice
    self._processMap["changeRemoteUserSite"] = Processor.process_changeRemoteUserSite
    self._processMap["getRemoteUser"] = Processor.process_getRemoteUser

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_deviceSignIn(self, seqid, iprot, oprot):
    args = deviceSignIn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deviceSignIn_result()
    result.success = self._handler.deviceSignIn(args.device, args.fromSite)
    oprot.writeMessageBegin("deviceSignIn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deviceEventReport(self, seqid, iprot, oprot):
    args = deviceEventReport_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deviceEventReport_result()
    self._handler.deviceEventReport(args.devEvent, args.fromSite)
    oprot.writeMessageBegin("deviceEventReport", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deviceConn(self, seqid, iprot, oprot):
    args = deviceConn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deviceConn_result()
    result.success = self._handler.deviceConn(args.req, args.fromSite)
    oprot.writeMessageBegin("deviceConn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bindRemoteDevice(self, seqid, iprot, oprot):
    args = bindRemoteDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bindRemoteDevice_result()
    result.success = self._handler.bindRemoteDevice(args.deviceId, args.accessKey, args.fromSite)
    oprot.writeMessageBegin("bindRemoteDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRemoteDevice(self, seqid, iprot, oprot):
    args = getRemoteDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRemoteDevice_result()
    try:
      result.success = self._handler.getRemoteDevice(args.deviceId, args.fromSite)
    except InvalidDeviceException, ide:
      result.ide = ide
    oprot.writeMessageBegin("getRemoteDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setRemoteDevice(self, seqid, iprot, oprot):
    args = setRemoteDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setRemoteDevice_result()
    try:
      result.success = self._handler.setRemoteDevice(args.device, args.fromSite)
    except InvalidDeviceException, ide:
      result.ide = ide
    oprot.writeMessageBegin("setRemoteDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_changeRemoteUserSite(self, seqid, iprot, oprot):
    args = changeRemoteUserSite_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = changeRemoteUserSite_result()
    try:
      result.success = self._handler.changeRemoteUserSite(args.email, args.changeToSite, args.fromSite)
    except InvalidUserException, iue:
      result.iue = iue
    oprot.writeMessageBegin("changeRemoteUserSite", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRemoteUser(self, seqid, iprot, oprot):
    args = getRemoteUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRemoteUser_result()
    try:
      result.success = self._handler.getRemoteUser(args.email, args.fromSite)
    except InvalidUserException, iue:
      result.iue = iue
    oprot.writeMessageBegin("getRemoteUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class deviceSignIn_args(object):
  """
  Attributes:
   - device
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'device', (Device, Device.thrift_spec), None, ), # 1
    (2, TType.STRING, 'fromSite', None, None, ), # 2
  )

  def __init__(self, device=None, fromSite=None,):
    self.device = device
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceSignIn_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.STRUCT, 1)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 2)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deviceSignIn_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceSignIn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deviceEventReport_args(object):
  """
  Attributes:
   - devEvent
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'devEvent', (DeviceEvent, DeviceEvent.thrift_spec), None, ), # 1
    (2, TType.STRING, 'fromSite', None, None, ), # 2
  )

  def __init__(self, devEvent=None, fromSite=None,):
    self.devEvent = devEvent
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.devEvent = DeviceEvent()
          self.devEvent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceEventReport_args')
    if self.devEvent is not None:
      oprot.writeFieldBegin('devEvent', TType.STRUCT, 1)
      self.devEvent.write(oprot)
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 2)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deviceEventReport_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceEventReport_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deviceConn_args(object):
  """
  Attributes:
   - req
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (DeviceConnRequest, DeviceConnRequest.thrift_spec), None, ), # 1
    (2, TType.STRING, 'fromSite', None, None, ), # 2
  )

  def __init__(self, req=None, fromSite=None,):
    self.req = req
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = DeviceConnRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceConn_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 2)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deviceConn_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DeviceConnResponse, DeviceConnResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DeviceConnResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceConn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bindRemoteDevice_args(object):
  """
  Attributes:
   - deviceId
   - accessKey
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.STRING, 'accessKey', None, None, ), # 2
    (3, TType.STRING, 'fromSite', None, None, ), # 3
  )

  def __init__(self, deviceId=None, accessKey=None, fromSite=None,):
    self.deviceId = deviceId
    self.accessKey = accessKey
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bindRemoteDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 2)
      oprot.writeString(self.accessKey.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 3)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bindRemoteDevice_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bindRemoteDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRemoteDevice_args(object):
  """
  Attributes:
   - deviceId
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.STRING, 'fromSite', None, None, ), # 2
  )

  def __init__(self, deviceId=None, fromSite=None,):
    self.deviceId = deviceId
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRemoteDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 2)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRemoteDevice_result(object):
  """
  Attributes:
   - success
   - ide
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ide=None,):
    self.success = success
    self.ide = ide

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRemoteDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 1)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setRemoteDevice_args(object):
  """
  Attributes:
   - device
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'device', (Device, Device.thrift_spec), None, ), # 1
    (2, TType.STRING, 'fromSite', None, None, ), # 2
  )

  def __init__(self, device=None, fromSite=None,):
    self.device = device
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setRemoteDevice_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.STRUCT, 1)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 2)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setRemoteDevice_result(object):
  """
  Attributes:
   - success
   - ide
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ide=None,):
    self.success = success
    self.ide = ide

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setRemoteDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 1)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeRemoteUserSite_args(object):
  """
  Attributes:
   - email
   - changeToSite
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'email', None, None, ), # 1
    (2, TType.STRING, 'changeToSite', None, None, ), # 2
    (3, TType.STRING, 'fromSite', None, None, ), # 3
  )

  def __init__(self, email=None, changeToSite=None, fromSite=None,):
    self.email = email
    self.changeToSite = changeToSite
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.changeToSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeRemoteUserSite_args')
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 1)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.changeToSite is not None:
      oprot.writeFieldBegin('changeToSite', TType.STRING, 2)
      oprot.writeString(self.changeToSite.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 3)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeRemoteUserSite_result(object):
  """
  Attributes:
   - success
   - iue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iue', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iue=None,):
    self.success = success
    self.iue = iue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iue = InvalidUserException()
          self.iue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeRemoteUserSite_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iue is not None:
      oprot.writeFieldBegin('iue', TType.STRUCT, 1)
      self.iue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRemoteUser_args(object):
  """
  Attributes:
   - email
   - fromSite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'email', None, None, ), # 1
    (2, TType.STRING, 'fromSite', None, None, ), # 2
  )

  def __init__(self, email=None, fromSite=None,):
    self.email = email
    self.fromSite = fromSite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fromSite = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRemoteUser_args')
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 1)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromSite is not None:
      oprot.writeFieldBegin('fromSite', TType.STRING, 2)
      oprot.writeString(self.fromSite.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRemoteUser_result(object):
  """
  Attributes:
   - success
   - iue
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (User, User.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iue', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iue=None,):
    self.success = success
    self.iue = iue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iue = InvalidUserException()
          self.iue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRemoteUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iue is not None:
      oprot.writeFieldBegin('iue', TType.STRUCT, 1)
      self.iue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
