#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import gabriel.SharedService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(gabriel.SharedService.Iface):
  """
  ***************************************************************************
    Service
  ***************************************************************************
  """
  def ping(self, ):
    pass

  def stop(self, ):
    pass

  def reload(self, ):
    pass

  def isAppRegistered(self, appId):
    """
    Parameters:
     - appId
    """
    pass

  def authenApp(self, app):
    """
    Parameters:
     - app
    """
    pass

  def authApp(self, appId, user):
    """
    Parameters:
     - appId
     - user
    """
    pass

  def unauthApp(self, appId, user):
    """
    Parameters:
     - appId
     - user
    """
    pass

  def grantApp(self, authCode):
    """
    Parameters:
     - authCode
    """
    pass

  def getAccessToken(self, accessToken, app):
    """
    Parameters:
     - accessToken
     - app
    """
    pass

  def renewAccessToken(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    pass

  def registerUser(self, appToken, user, confirmUrl):
    """
    Parameters:
     - appToken
     - user
     - confirmUrl
    """
    pass

  def createUser(self, appToken, user):
    """
    Parameters:
     - appToken
     - user
    """
    pass

  def deleteUserByApp(self, appToken, user):
    """
    Parameters:
     - appToken
     - user
    """
    pass

  def forgetPasswd(self, appToken, user, url):
    """
    Parameters:
     - appToken
     - user
     - url
    """
    pass

  def resetPasswd(self, passwdKey, newPasswd, email):
    """
    Parameters:
     - passwdKey
     - newPasswd
     - email
    """
    pass

  def retrieveUser(self, token):
    """
    Parameters:
     - token
    """
    pass

  def retrieveUserProfile(self, token):
    """
    Parameters:
     - token
    """
    pass

  def updateUser(self, token, user):
    """
    Parameters:
     - token
     - user
    """
    pass

  def deleteUser(self, token, userPasswd):
    """
    Parameters:
     - token
     - userPasswd
    """
    pass

  def changeEmail(self, token, userPasswd, newEmail, confirmUrl):
    """
    Parameters:
     - token
     - userPasswd
     - newEmail
     - confirmUrl
    """
    pass

  def changePasswd(self, token, oldPasswd, newPasswd):
    """
    Parameters:
     - token
     - oldPasswd
     - newPasswd
    """
    pass

  def confirmUser(self, email, confirmKey):
    """
    Parameters:
     - email
     - confirmKey
    """
    pass

  def resendConfirmKey(self, token, confirmUrl):
    """
    Parameters:
     - token
     - confirmUrl
    """
    pass

  def bindDevice(self, accessToken, deviceId, accessKey):
    """
    Parameters:
     - accessToken
     - deviceId
     - accessKey
    """
    pass

  def unbindDevice(self, accessToken, deviceId, userPasswd):
    """
    Parameters:
     - accessToken
     - deviceId
     - userPasswd
    """
    pass

  def validateDeviceAccess(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    pass

  def getDeviceListByAccessToken(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    pass

  def getSldNameByDeviceId(self, deviceId):
    """
    Parameters:
     - deviceId
    """
    pass

  def publishDevice(self, accessToken, device):
    """
    Parameters:
     - accessToken
     - device
    """
    pass

  def cancelPublicDevice(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    pass

  def updateDevice(self, accessToken, device):
    """
    Parameters:
     - accessToken
     - device
    """
    pass

  def getPublicDeviceById(self, appToken, deviceId):
    """
    Parameters:
     - appToken
     - deviceId
    """
    pass

  def getTopPublicDevice(self, appToken, topNumber):
    """
    Parameters:
     - appToken
     - topNumber
    """
    pass

  def searchPublicDevice(self, appToken, center, range, maximum):
    """
    Parameters:
     - appToken
     - center
     - range
     - maximum
    """
    pass

  def addFavoriteDevice(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    pass

  def removeFavoriteDevice(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    pass

  def getFavoriteDevice(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    pass

  def deviceConnReq(self, accessToken, req):
    """
    Parameters:
     - accessToken
     - req
    """
    pass

  def pubDeviceConnReq(self, accessToken, req):
    """
    Parameters:
     - accessToken
     - req
    """
    pass

  def updateRecordingMeta(self, deviceId, metaInfo):
    """
    Parameters:
     - deviceId
     - metaInfo
    """
    pass

  def addGroup(self, token, groupName):
    """
      metaInfo={"sessionId": 'eaa53223-8682-44f8-b793-f69bf149f144-0',
    			 "fileUrl:","http://record.mydlink.com",
      (JSON)          "storageType",'local"}

    *

    Parameters:
     - token
     - groupName
    """
    pass

  def modifyGroup(self, token, groupTitle):
    """
    Parameters:
     - token
     - groupTitle
    """
    pass

  def deleteGroup(self, token, groupId):
    """
    Parameters:
     - token
     - groupId
    """
    pass

  def getGroupTitleByGroupId(self, token, groupId):
    """
    Parameters:
     - token
     - groupId
    """
    pass

  def getGroupList(self, token):
    """
    Parameters:
     - token
    """
    pass

  def addGroupMember(self, token, groupId, contacts):
    """
    Parameters:
     - token
     - groupId
     - contacts
    """
    pass

  def updateGroupMember(self, token, groupId, contacts):
    """
    Parameters:
     - token
     - groupId
     - contacts
    """
    pass

  def deleteGroupMember(self, token, groupId, emails):
    """
    Parameters:
     - token
     - groupId
     - emails
    """
    pass

  def getGroupMemberByGroupId(self, token, groupId):
    """
    Parameters:
     - token
     - groupId
    """
    pass

  def shareDeviceToUsers(self, token, deviceId, sharingList, shareUrl):
    """
    Parameters:
     - token
     - deviceId
     - sharingList
     - shareUrl
    """
    pass

  def updateDeviceSharing(self, token, deviceId, sharingList):
    """
    Parameters:
     - token
     - deviceId
     - sharingList
    """
    pass

  def shareDeviceToGroups(self, token, deviceId, groupIds, shareUrl):
    """
    Parameters:
     - token
     - deviceId
     - groupIds
     - shareUrl
    """
    pass

  def revokeSharingDevice(self, token, deviceId, emails):
    """
    Parameters:
     - token
     - deviceId
     - emails
    """
    pass

  def sendEmailToCreateAccount(self, token, email):
    """
    Parameters:
     - token
     - email
    """
    pass

  def getSharingList(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    pass

  def setSharingDevice(self, token, deviceId, sharable):
    """
    Parameters:
     - token
     - deviceId
     - sharable
    """
    pass

  def getPendingDeviceList(self, token):
    """
    Parameters:
     - token
    """
    pass

  def acceptSharingDevice(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    pass

  def deleteSharingDevice(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    pass

  def resendDeviceSharing(self, token, deviceId, shareeEmails, shareUrl):
    """
    Parameters:
     - token
     - deviceId
     - shareeEmails
     - shareUrl
    """
    pass

  def findRecords(self, token, startTime, endTime, mydlinkId, trigger, keyword):
    """
     * Search records by provided parameters
     * @param userid, necessary, user id
     * @param startTime,necessary,start time in milliseconds
     * @param endTime,necessary,end time in milliseconds, endTime-startTime should be in one
     * month,ie 31 days.If period exceeds one month,service will cut off the period into one
     * month.
     * @param mydlinkId,optional,device mydlinkId
     * @param trigger,optional,record trigger type,"manual","motion","scheduled"
     * @param keyword,optional,if it is setted,service will search keyword in record description
    *

    Parameters:
     - token
     - startTime
     - endTime
     - mydlinkId
     - trigger
     - keyword
    """
    pass

  def getDeviceByDeviceId(self, deviceId):
    """
    Parameters:
     - deviceId
    """
    pass

  def getUserByEmail(self, email):
    """
    Parameters:
     - email
    """
    pass

  def getUserByUserId(self, userId):
    """
    Parameters:
     - userId
    """
    pass

  def sendEventNotification(self, deviceEventNotification):
    """
    Parameters:
     - deviceEventNotification
    """
    pass

  def searchDeviceEventLog(self, token, deviceId, severities, startTime, endTime, total):
    """
     Search device event/alarm by provided parameters
     @param token, user's access token,required
     @param deviceId, required
     @param severities,required
     @param startTime, optional, '0' considered not provided
     @param endTime, optional,'0' considered not provided
     @param total,maximum return number,optional,'0' considered not provided
    **

    Parameters:
     - token
     - deviceId
     - severities
     - startTime
     - endTime
     - total
    """
    pass

  def ackAlarm(self, token, deviceId, startTime, endTime):
    """
     acknownledge alert
     @param token, user's access token,required.
     @param deviceId, required.
     @param startTime,required. '0' is considered ack all alarm up to endTime
     @param endTime, required.
            "startTime==endTime" is considered to ack individual alarm

    *

    Parameters:
     - token
     - deviceId
     - startTime
     - endTime
    """
    pass

  def getUnreadAlarms(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    pass

  def getNotificationSetting(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    pass

  def registerMobileToken(self, token, mobileToken, displayName, mobileType):
    """
    Parameters:
     - token
     - mobileToken
     - displayName
     - mobileType
    """
    pass

  def removeMobileToken(self, appToken, mobileTokens):
    """
    Parameters:
     - appToken
     - mobileTokens
    """
    pass

  def listMobileToken(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    pass

  def sendTxtMsgToGsenderQueue(self, message):
    """
    Parameters:
     - message
    """
    pass


class Client(gabriel.SharedService.Client, Iface):
  """
  ***************************************************************************
    Service
  ***************************************************************************
  """
  def __init__(self, iprot, oprot=None):
    gabriel.SharedService.Client.__init__(self, iprot, oprot)

  def ping(self, ):
    self.send_ping()
    self.recv_ping()

  def send_ping(self, ):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def stop(self, ):
    self.send_stop()

  def send_stop(self, ):
    self._oprot.writeMessageBegin('stop', TMessageType.CALL, self._seqid)
    args = stop_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def reload(self, ):
    self.send_reload()
    self.recv_reload()

  def send_reload(self, ):
    self._oprot.writeMessageBegin('reload', TMessageType.CALL, self._seqid)
    args = reload_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reload(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = reload_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def isAppRegistered(self, appId):
    """
    Parameters:
     - appId
    """
    self.send_isAppRegistered(appId)
    return self.recv_isAppRegistered()

  def send_isAppRegistered(self, appId):
    self._oprot.writeMessageBegin('isAppRegistered', TMessageType.CALL, self._seqid)
    args = isAppRegistered_args()
    args.appId = appId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isAppRegistered(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = isAppRegistered_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ue is not None:
      raise result.ue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isAppRegistered failed: unknown result");

  def authenApp(self, app):
    """
    Parameters:
     - app
    """
    self.send_authenApp(app)
    return self.recv_authenApp()

  def send_authenApp(self, app):
    self._oprot.writeMessageBegin('authenApp', TMessageType.CALL, self._seqid)
    args = authenApp_args()
    args.app = app
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenApp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenApp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ue is not None:
      raise result.ue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenApp failed: unknown result");

  def authApp(self, appId, user):
    """
    Parameters:
     - appId
     - user
    """
    self.send_authApp(appId, user)
    return self.recv_authApp()

  def send_authApp(self, appId, user):
    self._oprot.writeMessageBegin('authApp', TMessageType.CALL, self._seqid)
    args = authApp_args()
    args.appId = appId
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authApp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authApp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ie is not None:
      raise result.ie
    if result.uue is not None:
      raise result.uue
    if result.ue is not None:
      raise result.ue
    if result.ise is not None:
      raise result.ise
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authApp failed: unknown result");

  def unauthApp(self, appId, user):
    """
    Parameters:
     - appId
     - user
    """
    self.send_unauthApp(appId, user)
    return self.recv_unauthApp()

  def send_unauthApp(self, appId, user):
    self._oprot.writeMessageBegin('unauthApp', TMessageType.CALL, self._seqid)
    args = unauthApp_args()
    args.appId = appId
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unauthApp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unauthApp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ie is not None:
      raise result.ie
    if result.uue is not None:
      raise result.uue
    if result.uae is not None:
      raise result.uae
    if result.ue is not None:
      raise result.ue
    if result.ise is not None:
      raise result.ise
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unauthApp failed: unknown result");

  def grantApp(self, authCode):
    """
    Parameters:
     - authCode
    """
    self.send_grantApp(authCode)
    return self.recv_grantApp()

  def send_grantApp(self, authCode):
    self._oprot.writeMessageBegin('grantApp', TMessageType.CALL, self._seqid)
    args = grantApp_args()
    args.authCode = authCode
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grantApp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = grantApp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ie is not None:
      raise result.ie
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grantApp failed: unknown result");

  def getAccessToken(self, accessToken, app):
    """
    Parameters:
     - accessToken
     - app
    """
    self.send_getAccessToken(accessToken, app)
    return self.recv_getAccessToken()

  def send_getAccessToken(self, accessToken, app):
    self._oprot.writeMessageBegin('getAccessToken', TMessageType.CALL, self._seqid)
    args = getAccessToken_args()
    args.accessToken = accessToken
    args.app = app
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAccessToken(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAccessToken_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ie is not None:
      raise result.ie
    if result.ue is not None:
      raise result.ue
    if result.iae is not None:
      raise result.iae
    if result.dte is not None:
      raise result.dte
    if result.ite is not None:
      raise result.ite
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAccessToken failed: unknown result");

  def renewAccessToken(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    self.send_renewAccessToken(accessToken)
    return self.recv_renewAccessToken()

  def send_renewAccessToken(self, accessToken):
    self._oprot.writeMessageBegin('renewAccessToken', TMessageType.CALL, self._seqid)
    args = renewAccessToken_args()
    args.accessToken = accessToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_renewAccessToken(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = renewAccessToken_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "renewAccessToken failed: unknown result");

  def registerUser(self, appToken, user, confirmUrl):
    """
    Parameters:
     - appToken
     - user
     - confirmUrl
    """
    self.send_registerUser(appToken, user, confirmUrl)
    return self.recv_registerUser()

  def send_registerUser(self, appToken, user, confirmUrl):
    self._oprot.writeMessageBegin('registerUser', TMessageType.CALL, self._seqid)
    args = registerUser_args()
    args.appToken = appToken
    args.user = user
    args.confirmUrl = confirmUrl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_registerUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = registerUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.eue is not None:
      raise result.eue
    if result.ioe is not None:
      raise result.ioe
    if result.ipe is not None:
      raise result.ipe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "registerUser failed: unknown result");

  def createUser(self, appToken, user):
    """
    Parameters:
     - appToken
     - user
    """
    self.send_createUser(appToken, user)
    return self.recv_createUser()

  def send_createUser(self, appToken, user):
    self._oprot.writeMessageBegin('createUser', TMessageType.CALL, self._seqid)
    args = createUser_args()
    args.appToken = appToken
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.eue is not None:
      raise result.eue
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result");

  def deleteUserByApp(self, appToken, user):
    """
    Parameters:
     - appToken
     - user
    """
    self.send_deleteUserByApp(appToken, user)
    return self.recv_deleteUserByApp()

  def send_deleteUserByApp(self, appToken, user):
    self._oprot.writeMessageBegin('deleteUserByApp', TMessageType.CALL, self._seqid)
    args = deleteUserByApp_args()
    args.appToken = appToken
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteUserByApp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteUserByApp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteUserByApp failed: unknown result");

  def forgetPasswd(self, appToken, user, url):
    """
    Parameters:
     - appToken
     - user
     - url
    """
    self.send_forgetPasswd(appToken, user, url)
    return self.recv_forgetPasswd()

  def send_forgetPasswd(self, appToken, user, url):
    self._oprot.writeMessageBegin('forgetPasswd', TMessageType.CALL, self._seqid)
    args = forgetPasswd_args()
    args.appToken = appToken
    args.user = user
    args.url = url
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_forgetPasswd(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = forgetPasswd_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    if result.ue is not None:
      raise result.ue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "forgetPasswd failed: unknown result");

  def resetPasswd(self, passwdKey, newPasswd, email):
    """
    Parameters:
     - passwdKey
     - newPasswd
     - email
    """
    self.send_resetPasswd(passwdKey, newPasswd, email)
    return self.recv_resetPasswd()

  def send_resetPasswd(self, passwdKey, newPasswd, email):
    self._oprot.writeMessageBegin('resetPasswd', TMessageType.CALL, self._seqid)
    args = resetPasswd_args()
    args.passwdKey = passwdKey
    args.newPasswd = newPasswd
    args.email = email
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resetPasswd(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resetPasswd_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    if result.uue is not None:
      raise result.uue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resetPasswd failed: unknown result");

  def retrieveUser(self, token):
    """
    Parameters:
     - token
    """
    self.send_retrieveUser(token)
    return self.recv_retrieveUser()

  def send_retrieveUser(self, token):
    self._oprot.writeMessageBegin('retrieveUser', TMessageType.CALL, self._seqid)
    args = retrieveUser_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_retrieveUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = retrieveUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "retrieveUser failed: unknown result");

  def retrieveUserProfile(self, token):
    """
    Parameters:
     - token
    """
    self.send_retrieveUserProfile(token)
    return self.recv_retrieveUserProfile()

  def send_retrieveUserProfile(self, token):
    self._oprot.writeMessageBegin('retrieveUserProfile', TMessageType.CALL, self._seqid)
    args = retrieveUserProfile_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_retrieveUserProfile(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = retrieveUserProfile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "retrieveUserProfile failed: unknown result");

  def updateUser(self, token, user):
    """
    Parameters:
     - token
     - user
    """
    self.send_updateUser(token, user)
    return self.recv_updateUser()

  def send_updateUser(self, token, user):
    self._oprot.writeMessageBegin('updateUser', TMessageType.CALL, self._seqid)
    args = updateUser_args()
    args.token = token
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateUser failed: unknown result");

  def deleteUser(self, token, userPasswd):
    """
    Parameters:
     - token
     - userPasswd
    """
    self.send_deleteUser(token, userPasswd)
    return self.recv_deleteUser()

  def send_deleteUser(self, token, userPasswd):
    self._oprot.writeMessageBegin('deleteUser', TMessageType.CALL, self._seqid)
    args = deleteUser_args()
    args.token = token
    args.userPasswd = userPasswd
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ie is not None:
      raise result.ie
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteUser failed: unknown result");

  def changeEmail(self, token, userPasswd, newEmail, confirmUrl):
    """
    Parameters:
     - token
     - userPasswd
     - newEmail
     - confirmUrl
    """
    self.send_changeEmail(token, userPasswd, newEmail, confirmUrl)
    return self.recv_changeEmail()

  def send_changeEmail(self, token, userPasswd, newEmail, confirmUrl):
    self._oprot.writeMessageBegin('changeEmail', TMessageType.CALL, self._seqid)
    args = changeEmail_args()
    args.token = token
    args.userPasswd = userPasswd
    args.newEmail = newEmail
    args.confirmUrl = confirmUrl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_changeEmail(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = changeEmail_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    if result.ie is not None:
      raise result.ie
    if result.eue is not None:
      raise result.eue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "changeEmail failed: unknown result");

  def changePasswd(self, token, oldPasswd, newPasswd):
    """
    Parameters:
     - token
     - oldPasswd
     - newPasswd
    """
    self.send_changePasswd(token, oldPasswd, newPasswd)
    return self.recv_changePasswd()

  def send_changePasswd(self, token, oldPasswd, newPasswd):
    self._oprot.writeMessageBegin('changePasswd', TMessageType.CALL, self._seqid)
    args = changePasswd_args()
    args.token = token
    args.oldPasswd = oldPasswd
    args.newPasswd = newPasswd
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_changePasswd(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = changePasswd_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    if result.ue is not None:
      raise result.ue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "changePasswd failed: unknown result");

  def confirmUser(self, email, confirmKey):
    """
    Parameters:
     - email
     - confirmKey
    """
    self.send_confirmUser(email, confirmKey)
    return self.recv_confirmUser()

  def send_confirmUser(self, email, confirmKey):
    self._oprot.writeMessageBegin('confirmUser', TMessageType.CALL, self._seqid)
    args = confirmUser_args()
    args.email = email
    args.confirmKey = confirmKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_confirmUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = confirmUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    if result.ue is not None:
      raise result.ue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "confirmUser failed: unknown result");

  def resendConfirmKey(self, token, confirmUrl):
    """
    Parameters:
     - token
     - confirmUrl
    """
    self.send_resendConfirmKey(token, confirmUrl)
    return self.recv_resendConfirmKey()

  def send_resendConfirmKey(self, token, confirmUrl):
    self._oprot.writeMessageBegin('resendConfirmKey', TMessageType.CALL, self._seqid)
    args = resendConfirmKey_args()
    args.token = token
    args.confirmUrl = confirmUrl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resendConfirmKey(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resendConfirmKey_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resendConfirmKey failed: unknown result");

  def bindDevice(self, accessToken, deviceId, accessKey):
    """
    Parameters:
     - accessToken
     - deviceId
     - accessKey
    """
    self.send_bindDevice(accessToken, deviceId, accessKey)
    return self.recv_bindDevice()

  def send_bindDevice(self, accessToken, deviceId, accessKey):
    self._oprot.writeMessageBegin('bindDevice', TMessageType.CALL, self._seqid)
    args = bindDevice_args()
    args.accessToken = accessToken
    args.deviceId = deviceId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bindDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = bindDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    if result.ipe is not None:
      raise result.ipe
    if result.ue is not None:
      raise result.ue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bindDevice failed: unknown result");

  def unbindDevice(self, accessToken, deviceId, userPasswd):
    """
    Parameters:
     - accessToken
     - deviceId
     - userPasswd
    """
    self.send_unbindDevice(accessToken, deviceId, userPasswd)
    return self.recv_unbindDevice()

  def send_unbindDevice(self, accessToken, deviceId, userPasswd):
    self._oprot.writeMessageBegin('unbindDevice', TMessageType.CALL, self._seqid)
    args = unbindDevice_args()
    args.accessToken = accessToken
    args.deviceId = deviceId
    args.userPasswd = userPasswd
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unbindDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unbindDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ue is not None:
      raise result.ue
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unbindDevice failed: unknown result");

  def validateDeviceAccess(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    self.send_validateDeviceAccess(accessToken, deviceId)
    return self.recv_validateDeviceAccess()

  def send_validateDeviceAccess(self, accessToken, deviceId):
    self._oprot.writeMessageBegin('validateDeviceAccess', TMessageType.CALL, self._seqid)
    args = validateDeviceAccess_args()
    args.accessToken = accessToken
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_validateDeviceAccess(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = validateDeviceAccess_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "validateDeviceAccess failed: unknown result");

  def getDeviceListByAccessToken(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    self.send_getDeviceListByAccessToken(accessToken)
    return self.recv_getDeviceListByAccessToken()

  def send_getDeviceListByAccessToken(self, accessToken):
    self._oprot.writeMessageBegin('getDeviceListByAccessToken', TMessageType.CALL, self._seqid)
    args = getDeviceListByAccessToken_args()
    args.accessToken = accessToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDeviceListByAccessToken(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDeviceListByAccessToken_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceListByAccessToken failed: unknown result");

  def getSldNameByDeviceId(self, deviceId):
    """
    Parameters:
     - deviceId
    """
    self.send_getSldNameByDeviceId(deviceId)
    return self.recv_getSldNameByDeviceId()

  def send_getSldNameByDeviceId(self, deviceId):
    self._oprot.writeMessageBegin('getSldNameByDeviceId', TMessageType.CALL, self._seqid)
    args = getSldNameByDeviceId_args()
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSldNameByDeviceId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSldNameByDeviceId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSldNameByDeviceId failed: unknown result");

  def publishDevice(self, accessToken, device):
    """
    Parameters:
     - accessToken
     - device
    """
    self.send_publishDevice(accessToken, device)
    return self.recv_publishDevice()

  def send_publishDevice(self, accessToken, device):
    self._oprot.writeMessageBegin('publishDevice', TMessageType.CALL, self._seqid)
    args = publishDevice_args()
    args.accessToken = accessToken
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_publishDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = publishDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "publishDevice failed: unknown result");

  def cancelPublicDevice(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    self.send_cancelPublicDevice(accessToken, deviceId)
    return self.recv_cancelPublicDevice()

  def send_cancelPublicDevice(self, accessToken, deviceId):
    self._oprot.writeMessageBegin('cancelPublicDevice', TMessageType.CALL, self._seqid)
    args = cancelPublicDevice_args()
    args.accessToken = accessToken
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cancelPublicDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cancelPublicDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cancelPublicDevice failed: unknown result");

  def updateDevice(self, accessToken, device):
    """
    Parameters:
     - accessToken
     - device
    """
    self.send_updateDevice(accessToken, device)
    return self.recv_updateDevice()

  def send_updateDevice(self, accessToken, device):
    self._oprot.writeMessageBegin('updateDevice', TMessageType.CALL, self._seqid)
    args = updateDevice_args()
    args.accessToken = accessToken
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateDevice failed: unknown result");

  def getPublicDeviceById(self, appToken, deviceId):
    """
    Parameters:
     - appToken
     - deviceId
    """
    self.send_getPublicDeviceById(appToken, deviceId)
    return self.recv_getPublicDeviceById()

  def send_getPublicDeviceById(self, appToken, deviceId):
    self._oprot.writeMessageBegin('getPublicDeviceById', TMessageType.CALL, self._seqid)
    args = getPublicDeviceById_args()
    args.appToken = appToken
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPublicDeviceById(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPublicDeviceById_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPublicDeviceById failed: unknown result");

  def getTopPublicDevice(self, appToken, topNumber):
    """
    Parameters:
     - appToken
     - topNumber
    """
    self.send_getTopPublicDevice(appToken, topNumber)
    return self.recv_getTopPublicDevice()

  def send_getTopPublicDevice(self, appToken, topNumber):
    self._oprot.writeMessageBegin('getTopPublicDevice', TMessageType.CALL, self._seqid)
    args = getTopPublicDevice_args()
    args.appToken = appToken
    args.topNumber = topNumber
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTopPublicDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTopPublicDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTopPublicDevice failed: unknown result");

  def searchPublicDevice(self, appToken, center, range, maximum):
    """
    Parameters:
     - appToken
     - center
     - range
     - maximum
    """
    self.send_searchPublicDevice(appToken, center, range, maximum)
    return self.recv_searchPublicDevice()

  def send_searchPublicDevice(self, appToken, center, range, maximum):
    self._oprot.writeMessageBegin('searchPublicDevice', TMessageType.CALL, self._seqid)
    args = searchPublicDevice_args()
    args.appToken = appToken
    args.center = center
    args.range = range
    args.maximum = maximum
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_searchPublicDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = searchPublicDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "searchPublicDevice failed: unknown result");

  def addFavoriteDevice(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    self.send_addFavoriteDevice(accessToken, deviceId)
    return self.recv_addFavoriteDevice()

  def send_addFavoriteDevice(self, accessToken, deviceId):
    self._oprot.writeMessageBegin('addFavoriteDevice', TMessageType.CALL, self._seqid)
    args = addFavoriteDevice_args()
    args.accessToken = accessToken
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addFavoriteDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addFavoriteDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addFavoriteDevice failed: unknown result");

  def removeFavoriteDevice(self, accessToken, deviceId):
    """
    Parameters:
     - accessToken
     - deviceId
    """
    self.send_removeFavoriteDevice(accessToken, deviceId)
    return self.recv_removeFavoriteDevice()

  def send_removeFavoriteDevice(self, accessToken, deviceId):
    self._oprot.writeMessageBegin('removeFavoriteDevice', TMessageType.CALL, self._seqid)
    args = removeFavoriteDevice_args()
    args.accessToken = accessToken
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeFavoriteDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeFavoriteDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeFavoriteDevice failed: unknown result");

  def getFavoriteDevice(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    self.send_getFavoriteDevice(accessToken)
    return self.recv_getFavoriteDevice()

  def send_getFavoriteDevice(self, accessToken):
    self._oprot.writeMessageBegin('getFavoriteDevice', TMessageType.CALL, self._seqid)
    args = getFavoriteDevice_args()
    args.accessToken = accessToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFavoriteDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFavoriteDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFavoriteDevice failed: unknown result");

  def deviceConnReq(self, accessToken, req):
    """
    Parameters:
     - accessToken
     - req
    """
    self.send_deviceConnReq(accessToken, req)
    return self.recv_deviceConnReq()

  def send_deviceConnReq(self, accessToken, req):
    self._oprot.writeMessageBegin('deviceConnReq', TMessageType.CALL, self._seqid)
    args = deviceConnReq_args()
    args.accessToken = accessToken
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deviceConnReq(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deviceConnReq_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ioe is not None:
      raise result.ioe
    if result.ue is not None:
      raise result.ue
    if result.te is not None:
      raise result.te
    if result.idc is not None:
      raise result.idc
    if result.ide is not None:
      raise result.ide
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deviceConnReq failed: unknown result");

  def pubDeviceConnReq(self, accessToken, req):
    """
    Parameters:
     - accessToken
     - req
    """
    self.send_pubDeviceConnReq(accessToken, req)
    return self.recv_pubDeviceConnReq()

  def send_pubDeviceConnReq(self, accessToken, req):
    self._oprot.writeMessageBegin('pubDeviceConnReq', TMessageType.CALL, self._seqid)
    args = pubDeviceConnReq_args()
    args.accessToken = accessToken
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pubDeviceConnReq(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = pubDeviceConnReq_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ioe is not None:
      raise result.ioe
    if result.ue is not None:
      raise result.ue
    if result.te is not None:
      raise result.te
    if result.idc is not None:
      raise result.idc
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pubDeviceConnReq failed: unknown result");

  def updateRecordingMeta(self, deviceId, metaInfo):
    """
    Parameters:
     - deviceId
     - metaInfo
    """
    self.send_updateRecordingMeta(deviceId, metaInfo)
    self.recv_updateRecordingMeta()

  def send_updateRecordingMeta(self, deviceId, metaInfo):
    self._oprot.writeMessageBegin('updateRecordingMeta', TMessageType.CALL, self._seqid)
    args = updateRecordingMeta_args()
    args.deviceId = deviceId
    args.metaInfo = metaInfo
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateRecordingMeta(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateRecordingMeta_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def addGroup(self, token, groupName):
    """
      metaInfo={"sessionId": 'eaa53223-8682-44f8-b793-f69bf149f144-0',
    			 "fileUrl:","http://record.mydlink.com",
      (JSON)          "storageType",'local"}

    *

    Parameters:
     - token
     - groupName
    """
    self.send_addGroup(token, groupName)
    return self.recv_addGroup()

  def send_addGroup(self, token, groupName):
    self._oprot.writeMessageBegin('addGroup', TMessageType.CALL, self._seqid)
    args = addGroup_args()
    args.token = token
    args.groupName = groupName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addGroup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.eue is not None:
      raise result.eue
    if result.ivp is not None:
      raise result.ivp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addGroup failed: unknown result");

  def modifyGroup(self, token, groupTitle):
    """
    Parameters:
     - token
     - groupTitle
    """
    self.send_modifyGroup(token, groupTitle)
    return self.recv_modifyGroup()

  def send_modifyGroup(self, token, groupTitle):
    self._oprot.writeMessageBegin('modifyGroup', TMessageType.CALL, self._seqid)
    args = modifyGroup_args()
    args.token = token
    args.groupTitle = groupTitle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modifyGroup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = modifyGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.eue is not None:
      raise result.eue
    if result.ioe is not None:
      raise result.ioe
    if result.ivp is not None:
      raise result.ivp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modifyGroup failed: unknown result");

  def deleteGroup(self, token, groupId):
    """
    Parameters:
     - token
     - groupId
    """
    self.send_deleteGroup(token, groupId)
    return self.recv_deleteGroup()

  def send_deleteGroup(self, token, groupId):
    self._oprot.writeMessageBegin('deleteGroup', TMessageType.CALL, self._seqid)
    args = deleteGroup_args()
    args.token = token
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteGroup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.eue is not None:
      raise result.eue
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteGroup failed: unknown result");

  def getGroupTitleByGroupId(self, token, groupId):
    """
    Parameters:
     - token
     - groupId
    """
    self.send_getGroupTitleByGroupId(token, groupId)
    return self.recv_getGroupTitleByGroupId()

  def send_getGroupTitleByGroupId(self, token, groupId):
    self._oprot.writeMessageBegin('getGroupTitleByGroupId', TMessageType.CALL, self._seqid)
    args = getGroupTitleByGroupId_args()
    args.token = token
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroupTitleByGroupId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGroupTitleByGroupId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupTitleByGroupId failed: unknown result");

  def getGroupList(self, token):
    """
    Parameters:
     - token
    """
    self.send_getGroupList(token)
    return self.recv_getGroupList()

  def send_getGroupList(self, token):
    self._oprot.writeMessageBegin('getGroupList', TMessageType.CALL, self._seqid)
    args = getGroupList_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroupList(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGroupList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupList failed: unknown result");

  def addGroupMember(self, token, groupId, contacts):
    """
    Parameters:
     - token
     - groupId
     - contacts
    """
    self.send_addGroupMember(token, groupId, contacts)
    return self.recv_addGroupMember()

  def send_addGroupMember(self, token, groupId, contacts):
    self._oprot.writeMessageBegin('addGroupMember', TMessageType.CALL, self._seqid)
    args = addGroupMember_args()
    args.token = token
    args.groupId = groupId
    args.contacts = contacts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addGroupMember(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addGroupMember_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ioe is not None:
      raise result.ioe
    if result.ivp is not None:
      raise result.ivp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addGroupMember failed: unknown result");

  def updateGroupMember(self, token, groupId, contacts):
    """
    Parameters:
     - token
     - groupId
     - contacts
    """
    self.send_updateGroupMember(token, groupId, contacts)
    return self.recv_updateGroupMember()

  def send_updateGroupMember(self, token, groupId, contacts):
    self._oprot.writeMessageBegin('updateGroupMember', TMessageType.CALL, self._seqid)
    args = updateGroupMember_args()
    args.token = token
    args.groupId = groupId
    args.contacts = contacts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateGroupMember(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateGroupMember_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ioe is not None:
      raise result.ioe
    if result.ivp is not None:
      raise result.ivp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateGroupMember failed: unknown result");

  def deleteGroupMember(self, token, groupId, emails):
    """
    Parameters:
     - token
     - groupId
     - emails
    """
    self.send_deleteGroupMember(token, groupId, emails)
    return self.recv_deleteGroupMember()

  def send_deleteGroupMember(self, token, groupId, emails):
    self._oprot.writeMessageBegin('deleteGroupMember', TMessageType.CALL, self._seqid)
    args = deleteGroupMember_args()
    args.token = token
    args.groupId = groupId
    args.emails = emails
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteGroupMember(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteGroupMember_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteGroupMember failed: unknown result");

  def getGroupMemberByGroupId(self, token, groupId):
    """
    Parameters:
     - token
     - groupId
    """
    self.send_getGroupMemberByGroupId(token, groupId)
    return self.recv_getGroupMemberByGroupId()

  def send_getGroupMemberByGroupId(self, token, groupId):
    self._oprot.writeMessageBegin('getGroupMemberByGroupId', TMessageType.CALL, self._seqid)
    args = getGroupMemberByGroupId_args()
    args.token = token
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroupMemberByGroupId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGroupMemberByGroupId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupMemberByGroupId failed: unknown result");

  def shareDeviceToUsers(self, token, deviceId, sharingList, shareUrl):
    """
    Parameters:
     - token
     - deviceId
     - sharingList
     - shareUrl
    """
    self.send_shareDeviceToUsers(token, deviceId, sharingList, shareUrl)
    return self.recv_shareDeviceToUsers()

  def send_shareDeviceToUsers(self, token, deviceId, sharingList, shareUrl):
    self._oprot.writeMessageBegin('shareDeviceToUsers', TMessageType.CALL, self._seqid)
    args = shareDeviceToUsers_args()
    args.token = token
    args.deviceId = deviceId
    args.sharingList = sharingList
    args.shareUrl = shareUrl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shareDeviceToUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = shareDeviceToUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "shareDeviceToUsers failed: unknown result");

  def updateDeviceSharing(self, token, deviceId, sharingList):
    """
    Parameters:
     - token
     - deviceId
     - sharingList
    """
    self.send_updateDeviceSharing(token, deviceId, sharingList)
    return self.recv_updateDeviceSharing()

  def send_updateDeviceSharing(self, token, deviceId, sharingList):
    self._oprot.writeMessageBegin('updateDeviceSharing', TMessageType.CALL, self._seqid)
    args = updateDeviceSharing_args()
    args.token = token
    args.deviceId = deviceId
    args.sharingList = sharingList
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateDeviceSharing(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateDeviceSharing_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateDeviceSharing failed: unknown result");

  def shareDeviceToGroups(self, token, deviceId, groupIds, shareUrl):
    """
    Parameters:
     - token
     - deviceId
     - groupIds
     - shareUrl
    """
    self.send_shareDeviceToGroups(token, deviceId, groupIds, shareUrl)
    return self.recv_shareDeviceToGroups()

  def send_shareDeviceToGroups(self, token, deviceId, groupIds, shareUrl):
    self._oprot.writeMessageBegin('shareDeviceToGroups', TMessageType.CALL, self._seqid)
    args = shareDeviceToGroups_args()
    args.token = token
    args.deviceId = deviceId
    args.groupIds = groupIds
    args.shareUrl = shareUrl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shareDeviceToGroups(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = shareDeviceToGroups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    if result.iope is not None:
      raise result.iope
    raise TApplicationException(TApplicationException.MISSING_RESULT, "shareDeviceToGroups failed: unknown result");

  def revokeSharingDevice(self, token, deviceId, emails):
    """
    Parameters:
     - token
     - deviceId
     - emails
    """
    self.send_revokeSharingDevice(token, deviceId, emails)
    return self.recv_revokeSharingDevice()

  def send_revokeSharingDevice(self, token, deviceId, emails):
    self._oprot.writeMessageBegin('revokeSharingDevice', TMessageType.CALL, self._seqid)
    args = revokeSharingDevice_args()
    args.token = token
    args.deviceId = deviceId
    args.emails = emails
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revokeSharingDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = revokeSharingDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revokeSharingDevice failed: unknown result");

  def sendEmailToCreateAccount(self, token, email):
    """
    Parameters:
     - token
     - email
    """
    self.send_sendEmailToCreateAccount(token, email)
    return self.recv_sendEmailToCreateAccount()

  def send_sendEmailToCreateAccount(self, token, email):
    self._oprot.writeMessageBegin('sendEmailToCreateAccount', TMessageType.CALL, self._seqid)
    args = sendEmailToCreateAccount_args()
    args.token = token
    args.email = email
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendEmailToCreateAccount(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendEmailToCreateAccount_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendEmailToCreateAccount failed: unknown result");

  def getSharingList(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    self.send_getSharingList(token, deviceId)
    return self.recv_getSharingList()

  def send_getSharingList(self, token, deviceId):
    self._oprot.writeMessageBegin('getSharingList', TMessageType.CALL, self._seqid)
    args = getSharingList_args()
    args.token = token
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSharingList(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSharingList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSharingList failed: unknown result");

  def setSharingDevice(self, token, deviceId, sharable):
    """
    Parameters:
     - token
     - deviceId
     - sharable
    """
    self.send_setSharingDevice(token, deviceId, sharable)
    return self.recv_setSharingDevice()

  def send_setSharingDevice(self, token, deviceId, sharable):
    self._oprot.writeMessageBegin('setSharingDevice', TMessageType.CALL, self._seqid)
    args = setSharingDevice_args()
    args.token = token
    args.deviceId = deviceId
    args.sharable = sharable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setSharingDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setSharingDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setSharingDevice failed: unknown result");

  def getPendingDeviceList(self, token):
    """
    Parameters:
     - token
    """
    self.send_getPendingDeviceList(token)
    return self.recv_getPendingDeviceList()

  def send_getPendingDeviceList(self, token):
    self._oprot.writeMessageBegin('getPendingDeviceList', TMessageType.CALL, self._seqid)
    args = getPendingDeviceList_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPendingDeviceList(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPendingDeviceList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPendingDeviceList failed: unknown result");

  def acceptSharingDevice(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    self.send_acceptSharingDevice(token, deviceId)
    return self.recv_acceptSharingDevice()

  def send_acceptSharingDevice(self, token, deviceId):
    self._oprot.writeMessageBegin('acceptSharingDevice', TMessageType.CALL, self._seqid)
    args = acceptSharingDevice_args()
    args.token = token
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acceptSharingDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = acceptSharingDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acceptSharingDevice failed: unknown result");

  def deleteSharingDevice(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    self.send_deleteSharingDevice(token, deviceId)
    return self.recv_deleteSharingDevice()

  def send_deleteSharingDevice(self, token, deviceId):
    self._oprot.writeMessageBegin('deleteSharingDevice', TMessageType.CALL, self._seqid)
    args = deleteSharingDevice_args()
    args.token = token
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteSharingDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteSharingDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteSharingDevice failed: unknown result");

  def resendDeviceSharing(self, token, deviceId, shareeEmails, shareUrl):
    """
    Parameters:
     - token
     - deviceId
     - shareeEmails
     - shareUrl
    """
    self.send_resendDeviceSharing(token, deviceId, shareeEmails, shareUrl)
    return self.recv_resendDeviceSharing()

  def send_resendDeviceSharing(self, token, deviceId, shareeEmails, shareUrl):
    self._oprot.writeMessageBegin('resendDeviceSharing', TMessageType.CALL, self._seqid)
    args = resendDeviceSharing_args()
    args.token = token
    args.deviceId = deviceId
    args.shareeEmails = shareeEmails
    args.shareUrl = shareUrl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resendDeviceSharing(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resendDeviceSharing_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resendDeviceSharing failed: unknown result");

  def findRecords(self, token, startTime, endTime, mydlinkId, trigger, keyword):
    """
     * Search records by provided parameters
     * @param userid, necessary, user id
     * @param startTime,necessary,start time in milliseconds
     * @param endTime,necessary,end time in milliseconds, endTime-startTime should be in one
     * month,ie 31 days.If period exceeds one month,service will cut off the period into one
     * month.
     * @param mydlinkId,optional,device mydlinkId
     * @param trigger,optional,record trigger type,"manual","motion","scheduled"
     * @param keyword,optional,if it is setted,service will search keyword in record description
    *

    Parameters:
     - token
     - startTime
     - endTime
     - mydlinkId
     - trigger
     - keyword
    """
    self.send_findRecords(token, startTime, endTime, mydlinkId, trigger, keyword)
    return self.recv_findRecords()

  def send_findRecords(self, token, startTime, endTime, mydlinkId, trigger, keyword):
    self._oprot.writeMessageBegin('findRecords', TMessageType.CALL, self._seqid)
    args = findRecords_args()
    args.token = token
    args.startTime = startTime
    args.endTime = endTime
    args.mydlinkId = mydlinkId
    args.trigger = trigger
    args.keyword = keyword
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findRecords(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findRecords_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findRecords failed: unknown result");

  def getDeviceByDeviceId(self, deviceId):
    """
    Parameters:
     - deviceId
    """
    self.send_getDeviceByDeviceId(deviceId)
    return self.recv_getDeviceByDeviceId()

  def send_getDeviceByDeviceId(self, deviceId):
    self._oprot.writeMessageBegin('getDeviceByDeviceId', TMessageType.CALL, self._seqid)
    args = getDeviceByDeviceId_args()
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDeviceByDeviceId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDeviceByDeviceId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceByDeviceId failed: unknown result");

  def getUserByEmail(self, email):
    """
    Parameters:
     - email
    """
    self.send_getUserByEmail(email)
    return self.recv_getUserByEmail()

  def send_getUserByEmail(self, email):
    self._oprot.writeMessageBegin('getUserByEmail', TMessageType.CALL, self._seqid)
    args = getUserByEmail_args()
    args.email = email
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserByEmail(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserByEmail_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserByEmail failed: unknown result");

  def getUserByUserId(self, userId):
    """
    Parameters:
     - userId
    """
    self.send_getUserByUserId(userId)
    return self.recv_getUserByUserId()

  def send_getUserByUserId(self, userId):
    self._oprot.writeMessageBegin('getUserByUserId', TMessageType.CALL, self._seqid)
    args = getUserByUserId_args()
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserByUserId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserByUserId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserByUserId failed: unknown result");

  def sendEventNotification(self, deviceEventNotification):
    """
    Parameters:
     - deviceEventNotification
    """
    self.send_sendEventNotification(deviceEventNotification)
    return self.recv_sendEventNotification()

  def send_sendEventNotification(self, deviceEventNotification):
    self._oprot.writeMessageBegin('sendEventNotification', TMessageType.CALL, self._seqid)
    args = sendEventNotification_args()
    args.deviceEventNotification = deviceEventNotification
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendEventNotification(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendEventNotification_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ide is not None:
      raise result.ide
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendEventNotification failed: unknown result");

  def searchDeviceEventLog(self, token, deviceId, severities, startTime, endTime, total):
    """
     Search device event/alarm by provided parameters
     @param token, user's access token,required
     @param deviceId, required
     @param severities,required
     @param startTime, optional, '0' considered not provided
     @param endTime, optional,'0' considered not provided
     @param total,maximum return number,optional,'0' considered not provided
    **

    Parameters:
     - token
     - deviceId
     - severities
     - startTime
     - endTime
     - total
    """
    self.send_searchDeviceEventLog(token, deviceId, severities, startTime, endTime, total)
    return self.recv_searchDeviceEventLog()

  def send_searchDeviceEventLog(self, token, deviceId, severities, startTime, endTime, total):
    self._oprot.writeMessageBegin('searchDeviceEventLog', TMessageType.CALL, self._seqid)
    args = searchDeviceEventLog_args()
    args.token = token
    args.deviceId = deviceId
    args.severities = severities
    args.startTime = startTime
    args.endTime = endTime
    args.total = total
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_searchDeviceEventLog(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = searchDeviceEventLog_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "searchDeviceEventLog failed: unknown result");

  def ackAlarm(self, token, deviceId, startTime, endTime):
    """
     acknownledge alert
     @param token, user's access token,required.
     @param deviceId, required.
     @param startTime,required. '0' is considered ack all alarm up to endTime
     @param endTime, required.
            "startTime==endTime" is considered to ack individual alarm

    *

    Parameters:
     - token
     - deviceId
     - startTime
     - endTime
    """
    self.send_ackAlarm(token, deviceId, startTime, endTime)
    return self.recv_ackAlarm()

  def send_ackAlarm(self, token, deviceId, startTime, endTime):
    self._oprot.writeMessageBegin('ackAlarm', TMessageType.CALL, self._seqid)
    args = ackAlarm_args()
    args.token = token
    args.deviceId = deviceId
    args.startTime = startTime
    args.endTime = endTime
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ackAlarm(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ackAlarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ackAlarm failed: unknown result");

  def getUnreadAlarms(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    self.send_getUnreadAlarms(token, deviceId)
    return self.recv_getUnreadAlarms()

  def send_getUnreadAlarms(self, token, deviceId):
    self._oprot.writeMessageBegin('getUnreadAlarms', TMessageType.CALL, self._seqid)
    args = getUnreadAlarms_args()
    args.token = token
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUnreadAlarms(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUnreadAlarms_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUnreadAlarms failed: unknown result");

  def getNotificationSetting(self, token, deviceId):
    """
    Parameters:
     - token
     - deviceId
    """
    self.send_getNotificationSetting(token, deviceId)
    return self.recv_getNotificationSetting()

  def send_getNotificationSetting(self, token, deviceId):
    self._oprot.writeMessageBegin('getNotificationSetting', TMessageType.CALL, self._seqid)
    args = getNotificationSetting_args()
    args.token = token
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNotificationSetting(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNotificationSetting_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    if result.ide is not None:
      raise result.ide
    if result.ioe is not None:
      raise result.ioe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNotificationSetting failed: unknown result");

  def registerMobileToken(self, token, mobileToken, displayName, mobileType):
    """
    Parameters:
     - token
     - mobileToken
     - displayName
     - mobileType
    """
    self.send_registerMobileToken(token, mobileToken, displayName, mobileType)
    return self.recv_registerMobileToken()

  def send_registerMobileToken(self, token, mobileToken, displayName, mobileType):
    self._oprot.writeMessageBegin('registerMobileToken', TMessageType.CALL, self._seqid)
    args = registerMobileToken_args()
    args.token = token
    args.mobileToken = mobileToken
    args.displayName = displayName
    args.mobileType = mobileType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_registerMobileToken(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = registerMobileToken_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "registerMobileToken failed: unknown result");

  def removeMobileToken(self, appToken, mobileTokens):
    """
    Parameters:
     - appToken
     - mobileTokens
    """
    self.send_removeMobileToken(appToken, mobileTokens)
    return self.recv_removeMobileToken()

  def send_removeMobileToken(self, appToken, mobileTokens):
    self._oprot.writeMessageBegin('removeMobileToken', TMessageType.CALL, self._seqid)
    args = removeMobileToken_args()
    args.appToken = appToken
    args.mobileTokens = mobileTokens
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeMobileToken(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeMobileToken_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeMobileToken failed: unknown result");

  def listMobileToken(self, accessToken):
    """
    Parameters:
     - accessToken
    """
    self.send_listMobileToken(accessToken)
    return self.recv_listMobileToken()

  def send_listMobileToken(self, accessToken):
    self._oprot.writeMessageBegin('listMobileToken', TMessageType.CALL, self._seqid)
    args = listMobileToken_args()
    args.accessToken = accessToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listMobileToken(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listMobileToken_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.iae is not None:
      raise result.iae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listMobileToken failed: unknown result");

  def sendTxtMsgToGsenderQueue(self, message):
    """
    Parameters:
     - message
    """
    self.send_sendTxtMsgToGsenderQueue(message)
    return self.recv_sendTxtMsgToGsenderQueue()

  def send_sendTxtMsgToGsenderQueue(self, message):
    self._oprot.writeMessageBegin('sendTxtMsgToGsenderQueue', TMessageType.CALL, self._seqid)
    args = sendTxtMsgToGsenderQueue_args()
    args.message = message
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendTxtMsgToGsenderQueue(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendTxtMsgToGsenderQueue_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendTxtMsgToGsenderQueue failed: unknown result");


class Processor(gabriel.SharedService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    gabriel.SharedService.Processor.__init__(self, handler)
    self._processMap["ping"] = Processor.process_ping
    self._processMap["stop"] = Processor.process_stop
    self._processMap["reload"] = Processor.process_reload
    self._processMap["isAppRegistered"] = Processor.process_isAppRegistered
    self._processMap["authenApp"] = Processor.process_authenApp
    self._processMap["authApp"] = Processor.process_authApp
    self._processMap["unauthApp"] = Processor.process_unauthApp
    self._processMap["grantApp"] = Processor.process_grantApp
    self._processMap["getAccessToken"] = Processor.process_getAccessToken
    self._processMap["renewAccessToken"] = Processor.process_renewAccessToken
    self._processMap["registerUser"] = Processor.process_registerUser
    self._processMap["createUser"] = Processor.process_createUser
    self._processMap["deleteUserByApp"] = Processor.process_deleteUserByApp
    self._processMap["forgetPasswd"] = Processor.process_forgetPasswd
    self._processMap["resetPasswd"] = Processor.process_resetPasswd
    self._processMap["retrieveUser"] = Processor.process_retrieveUser
    self._processMap["retrieveUserProfile"] = Processor.process_retrieveUserProfile
    self._processMap["updateUser"] = Processor.process_updateUser
    self._processMap["deleteUser"] = Processor.process_deleteUser
    self._processMap["changeEmail"] = Processor.process_changeEmail
    self._processMap["changePasswd"] = Processor.process_changePasswd
    self._processMap["confirmUser"] = Processor.process_confirmUser
    self._processMap["resendConfirmKey"] = Processor.process_resendConfirmKey
    self._processMap["bindDevice"] = Processor.process_bindDevice
    self._processMap["unbindDevice"] = Processor.process_unbindDevice
    self._processMap["validateDeviceAccess"] = Processor.process_validateDeviceAccess
    self._processMap["getDeviceListByAccessToken"] = Processor.process_getDeviceListByAccessToken
    self._processMap["getSldNameByDeviceId"] = Processor.process_getSldNameByDeviceId
    self._processMap["publishDevice"] = Processor.process_publishDevice
    self._processMap["cancelPublicDevice"] = Processor.process_cancelPublicDevice
    self._processMap["updateDevice"] = Processor.process_updateDevice
    self._processMap["getPublicDeviceById"] = Processor.process_getPublicDeviceById
    self._processMap["getTopPublicDevice"] = Processor.process_getTopPublicDevice
    self._processMap["searchPublicDevice"] = Processor.process_searchPublicDevice
    self._processMap["addFavoriteDevice"] = Processor.process_addFavoriteDevice
    self._processMap["removeFavoriteDevice"] = Processor.process_removeFavoriteDevice
    self._processMap["getFavoriteDevice"] = Processor.process_getFavoriteDevice
    self._processMap["deviceConnReq"] = Processor.process_deviceConnReq
    self._processMap["pubDeviceConnReq"] = Processor.process_pubDeviceConnReq
    self._processMap["updateRecordingMeta"] = Processor.process_updateRecordingMeta
    self._processMap["addGroup"] = Processor.process_addGroup
    self._processMap["modifyGroup"] = Processor.process_modifyGroup
    self._processMap["deleteGroup"] = Processor.process_deleteGroup
    self._processMap["getGroupTitleByGroupId"] = Processor.process_getGroupTitleByGroupId
    self._processMap["getGroupList"] = Processor.process_getGroupList
    self._processMap["addGroupMember"] = Processor.process_addGroupMember
    self._processMap["updateGroupMember"] = Processor.process_updateGroupMember
    self._processMap["deleteGroupMember"] = Processor.process_deleteGroupMember
    self._processMap["getGroupMemberByGroupId"] = Processor.process_getGroupMemberByGroupId
    self._processMap["shareDeviceToUsers"] = Processor.process_shareDeviceToUsers
    self._processMap["updateDeviceSharing"] = Processor.process_updateDeviceSharing
    self._processMap["shareDeviceToGroups"] = Processor.process_shareDeviceToGroups
    self._processMap["revokeSharingDevice"] = Processor.process_revokeSharingDevice
    self._processMap["sendEmailToCreateAccount"] = Processor.process_sendEmailToCreateAccount
    self._processMap["getSharingList"] = Processor.process_getSharingList
    self._processMap["setSharingDevice"] = Processor.process_setSharingDevice
    self._processMap["getPendingDeviceList"] = Processor.process_getPendingDeviceList
    self._processMap["acceptSharingDevice"] = Processor.process_acceptSharingDevice
    self._processMap["deleteSharingDevice"] = Processor.process_deleteSharingDevice
    self._processMap["resendDeviceSharing"] = Processor.process_resendDeviceSharing
    self._processMap["findRecords"] = Processor.process_findRecords
    self._processMap["getDeviceByDeviceId"] = Processor.process_getDeviceByDeviceId
    self._processMap["getUserByEmail"] = Processor.process_getUserByEmail
    self._processMap["getUserByUserId"] = Processor.process_getUserByUserId
    self._processMap["sendEventNotification"] = Processor.process_sendEventNotification
    self._processMap["searchDeviceEventLog"] = Processor.process_searchDeviceEventLog
    self._processMap["ackAlarm"] = Processor.process_ackAlarm
    self._processMap["getUnreadAlarms"] = Processor.process_getUnreadAlarms
    self._processMap["getNotificationSetting"] = Processor.process_getNotificationSetting
    self._processMap["registerMobileToken"] = Processor.process_registerMobileToken
    self._processMap["removeMobileToken"] = Processor.process_removeMobileToken
    self._processMap["listMobileToken"] = Processor.process_listMobileToken
    self._processMap["sendTxtMsgToGsenderQueue"] = Processor.process_sendTxtMsgToGsenderQueue

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    self._handler.ping()
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stop(self, seqid, iprot, oprot):
    args = stop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.stop()
    return

  def process_reload(self, seqid, iprot, oprot):
    args = reload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reload_result()
    self._handler.reload()
    oprot.writeMessageBegin("reload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isAppRegistered(self, seqid, iprot, oprot):
    args = isAppRegistered_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isAppRegistered_result()
    try:
      result.success = self._handler.isAppRegistered(args.appId)
    except UnknownAppException, ue:
      result.ue = ue
    oprot.writeMessageBegin("isAppRegistered", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenApp(self, seqid, iprot, oprot):
    args = authenApp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenApp_result()
    try:
      result.success = self._handler.authenApp(args.app)
    except InvalidAppException, iae:
      result.iae = iae
    except UnknownAppException, ue:
      result.ue = ue
    oprot.writeMessageBegin("authenApp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authApp(self, seqid, iprot, oprot):
    args = authApp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authApp_result()
    try:
      result.success = self._handler.authApp(args.appId, args.user)
    except UnknownAppException, iae:
      result.iae = iae
    except InvalidUserException, ie:
      result.ie = ie
    except UnknownUserException, uue:
      result.uue = uue
    except UnavailableException, ue:
      result.ue = ue
    except IncorrectSiteException, ise:
      result.ise = ise
    oprot.writeMessageBegin("authApp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unauthApp(self, seqid, iprot, oprot):
    args = unauthApp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unauthApp_result()
    try:
      result.success = self._handler.unauthApp(args.appId, args.user)
    except InvalidUserException, ie:
      result.ie = ie
    except UnknownUserException, uue:
      result.uue = uue
    except UnknownAppException, uae:
      result.uae = uae
    except UnavailableException, ue:
      result.ue = ue
    except IncorrectSiteException, ise:
      result.ise = ise
    oprot.writeMessageBegin("unauthApp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grantApp(self, seqid, iprot, oprot):
    args = grantApp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grantApp_result()
    try:
      result.success = self._handler.grantApp(args.authCode)
    except InvalidOperationException, ie:
      result.ie = ie
    oprot.writeMessageBegin("grantApp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAccessToken(self, seqid, iprot, oprot):
    args = getAccessToken_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAccessToken_result()
    try:
      result.success = self._handler.getAccessToken(args.accessToken, args.app)
    except InvalidAppException, ie:
      result.ie = ie
    except UnknownAppException, ue:
      result.ue = ue
    except InvalidAuthCodeException, iae:
      result.iae = iae
    except DuplicateTimestampException, dte:
      result.dte = dte
    except InvalidTimestampException, ite:
      result.ite = ite
    oprot.writeMessageBegin("getAccessToken", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_renewAccessToken(self, seqid, iprot, oprot):
    args = renewAccessToken_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renewAccessToken_result()
    try:
      result.success = self._handler.renewAccessToken(args.accessToken)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("renewAccessToken", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_registerUser(self, seqid, iprot, oprot):
    args = registerUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = registerUser_result()
    try:
      result.success = self._handler.registerUser(args.appToken, args.user, args.confirmUrl)
    except ExistedEntityException, eue:
      result.eue = eue
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    except InvalidParamException, ipe:
      result.ipe = ipe
    oprot.writeMessageBegin("registerUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createUser(self, seqid, iprot, oprot):
    args = createUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createUser_result()
    try:
      result.success = self._handler.createUser(args.appToken, args.user)
    except ExistedEntityException, eue:
      result.eue = eue
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("createUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteUserByApp(self, seqid, iprot, oprot):
    args = deleteUserByApp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteUserByApp_result()
    try:
      result.success = self._handler.deleteUserByApp(args.appToken, args.user)
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("deleteUserByApp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_forgetPasswd(self, seqid, iprot, oprot):
    args = forgetPasswd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = forgetPasswd_result()
    try:
      result.success = self._handler.forgetPasswd(args.appToken, args.user, args.url)
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    except UnknownUserException, ue:
      result.ue = ue
    oprot.writeMessageBegin("forgetPasswd", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resetPasswd(self, seqid, iprot, oprot):
    args = resetPasswd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resetPasswd_result()
    try:
      result.success = self._handler.resetPasswd(args.passwdKey, args.newPasswd, args.email)
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    except UnknownUserException, uue:
      result.uue = uue
    oprot.writeMessageBegin("resetPasswd", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_retrieveUser(self, seqid, iprot, oprot):
    args = retrieveUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = retrieveUser_result()
    try:
      result.success = self._handler.retrieveUser(args.token)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("retrieveUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_retrieveUserProfile(self, seqid, iprot, oprot):
    args = retrieveUserProfile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = retrieveUserProfile_result()
    try:
      result.success = self._handler.retrieveUserProfile(args.token)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("retrieveUserProfile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateUser(self, seqid, iprot, oprot):
    args = updateUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateUser_result()
    try:
      result.success = self._handler.updateUser(args.token, args.user)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("updateUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteUser(self, seqid, iprot, oprot):
    args = deleteUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteUser_result()
    try:
      result.success = self._handler.deleteUser(args.token, args.userPasswd)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidUserException, ie:
      result.ie = ie
    except InvalidOperationException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("deleteUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_changeEmail(self, seqid, iprot, oprot):
    args = changeEmail_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = changeEmail_result()
    try:
      result.success = self._handler.changeEmail(args.token, args.userPasswd, args.newEmail, args.confirmUrl)
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    except InvalidUserException, ie:
      result.ie = ie
    except ExistedEntityException, eue:
      result.eue = eue
    oprot.writeMessageBegin("changeEmail", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_changePasswd(self, seqid, iprot, oprot):
    args = changePasswd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = changePasswd_result()
    try:
      result.success = self._handler.changePasswd(args.token, args.oldPasswd, args.newPasswd)
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    except InvalidUserException, ue:
      result.ue = ue
    oprot.writeMessageBegin("changePasswd", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_confirmUser(self, seqid, iprot, oprot):
    args = confirmUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = confirmUser_result()
    try:
      result.success = self._handler.confirmUser(args.email, args.confirmKey)
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    except InvalidUserException, ue:
      result.ue = ue
    oprot.writeMessageBegin("confirmUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resendConfirmKey(self, seqid, iprot, oprot):
    args = resendConfirmKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resendConfirmKey_result()
    try:
      result.success = self._handler.resendConfirmKey(args.token, args.confirmUrl)
    except InvalidAccessTokenException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("resendConfirmKey", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bindDevice(self, seqid, iprot, oprot):
    args = bindDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bindDevice_result()
    try:
      result.success = self._handler.bindDevice(args.accessToken, args.deviceId, args.accessKey)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    except InvalidParamException, ipe:
      result.ipe = ipe
    except UnavailableException, ue:
      result.ue = ue
    oprot.writeMessageBegin("bindDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unbindDevice(self, seqid, iprot, oprot):
    args = unbindDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unbindDevice_result()
    try:
      result.success = self._handler.unbindDevice(args.accessToken, args.deviceId, args.userPasswd)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ue:
      result.ue = ue
    oprot.writeMessageBegin("unbindDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_validateDeviceAccess(self, seqid, iprot, oprot):
    args = validateDeviceAccess_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = validateDeviceAccess_result()
    try:
      result.success = self._handler.validateDeviceAccess(args.accessToken, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("validateDeviceAccess", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDeviceListByAccessToken(self, seqid, iprot, oprot):
    args = getDeviceListByAccessToken_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDeviceListByAccessToken_result()
    try:
      result.success = self._handler.getDeviceListByAccessToken(args.accessToken)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("getDeviceListByAccessToken", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSldNameByDeviceId(self, seqid, iprot, oprot):
    args = getSldNameByDeviceId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSldNameByDeviceId_result()
    try:
      result.success = self._handler.getSldNameByDeviceId(args.deviceId)
    except InvalidOperationException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("getSldNameByDeviceId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_publishDevice(self, seqid, iprot, oprot):
    args = publishDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = publishDevice_result()
    try:
      result.success = self._handler.publishDevice(args.accessToken, args.device)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("publishDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cancelPublicDevice(self, seqid, iprot, oprot):
    args = cancelPublicDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancelPublicDevice_result()
    try:
      result.success = self._handler.cancelPublicDevice(args.accessToken, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("cancelPublicDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateDevice(self, seqid, iprot, oprot):
    args = updateDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateDevice_result()
    try:
      result.success = self._handler.updateDevice(args.accessToken, args.device)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("updateDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPublicDeviceById(self, seqid, iprot, oprot):
    args = getPublicDeviceById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPublicDeviceById_result()
    try:
      result.success = self._handler.getPublicDeviceById(args.appToken, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    oprot.writeMessageBegin("getPublicDeviceById", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTopPublicDevice(self, seqid, iprot, oprot):
    args = getTopPublicDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTopPublicDevice_result()
    try:
      result.success = self._handler.getTopPublicDevice(args.appToken, args.topNumber)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("getTopPublicDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_searchPublicDevice(self, seqid, iprot, oprot):
    args = searchPublicDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = searchPublicDevice_result()
    try:
      result.success = self._handler.searchPublicDevice(args.appToken, args.center, args.range, args.maximum)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("searchPublicDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addFavoriteDevice(self, seqid, iprot, oprot):
    args = addFavoriteDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addFavoriteDevice_result()
    try:
      result.success = self._handler.addFavoriteDevice(args.accessToken, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOperationException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("addFavoriteDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeFavoriteDevice(self, seqid, iprot, oprot):
    args = removeFavoriteDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeFavoriteDevice_result()
    try:
      result.success = self._handler.removeFavoriteDevice(args.accessToken, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOperationException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("removeFavoriteDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFavoriteDevice(self, seqid, iprot, oprot):
    args = getFavoriteDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFavoriteDevice_result()
    try:
      result.success = self._handler.getFavoriteDevice(args.accessToken)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("getFavoriteDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deviceConnReq(self, seqid, iprot, oprot):
    args = deviceConnReq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deviceConnReq_result()
    try:
      result.success = self._handler.deviceConnReq(args.accessToken, args.req)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidOperationException, ioe:
      result.ioe = ioe
    except UnavailableException, ue:
      result.ue = ue
    except TimedOutException, te:
      result.te = te
    except InvalidDeviceException, idc:
      result.idc = idc
    except InvalidOwnerException, ide:
      result.ide = ide
    oprot.writeMessageBegin("deviceConnReq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pubDeviceConnReq(self, seqid, iprot, oprot):
    args = pubDeviceConnReq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pubDeviceConnReq_result()
    try:
      result.success = self._handler.pubDeviceConnReq(args.accessToken, args.req)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidOperationException, ioe:
      result.ioe = ioe
    except UnavailableException, ue:
      result.ue = ue
    except TimedOutException, te:
      result.te = te
    except InvalidDeviceException, idc:
      result.idc = idc
    oprot.writeMessageBegin("pubDeviceConnReq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateRecordingMeta(self, seqid, iprot, oprot):
    args = updateRecordingMeta_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateRecordingMeta_result()
    self._handler.updateRecordingMeta(args.deviceId, args.metaInfo)
    oprot.writeMessageBegin("updateRecordingMeta", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addGroup(self, seqid, iprot, oprot):
    args = addGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addGroup_result()
    try:
      result.success = self._handler.addGroup(args.token, args.groupName)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except ExistedEntityException, eue:
      result.eue = eue
    except InvalidParamException, ivp:
      result.ivp = ivp
    oprot.writeMessageBegin("addGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modifyGroup(self, seqid, iprot, oprot):
    args = modifyGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modifyGroup_result()
    try:
      result.success = self._handler.modifyGroup(args.token, args.groupTitle)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except ExistedEntityException, eue:
      result.eue = eue
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    except InvalidParamException, ivp:
      result.ivp = ivp
    oprot.writeMessageBegin("modifyGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteGroup(self, seqid, iprot, oprot):
    args = deleteGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteGroup_result()
    try:
      result.success = self._handler.deleteGroup(args.token, args.groupId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except ExistedEntityException, eue:
      result.eue = eue
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("deleteGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroupTitleByGroupId(self, seqid, iprot, oprot):
    args = getGroupTitleByGroupId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroupTitleByGroupId_result()
    try:
      result.success = self._handler.getGroupTitleByGroupId(args.token, args.groupId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("getGroupTitleByGroupId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroupList(self, seqid, iprot, oprot):
    args = getGroupList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroupList_result()
    try:
      result.success = self._handler.getGroupList(args.token)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("getGroupList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addGroupMember(self, seqid, iprot, oprot):
    args = addGroupMember_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addGroupMember_result()
    try:
      result.success = self._handler.addGroupMember(args.token, args.groupId, args.contacts)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    except InvalidParamException, ivp:
      result.ivp = ivp
    oprot.writeMessageBegin("addGroupMember", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateGroupMember(self, seqid, iprot, oprot):
    args = updateGroupMember_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateGroupMember_result()
    try:
      result.success = self._handler.updateGroupMember(args.token, args.groupId, args.contacts)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    except InvalidParamException, ivp:
      result.ivp = ivp
    oprot.writeMessageBegin("updateGroupMember", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteGroupMember(self, seqid, iprot, oprot):
    args = deleteGroupMember_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteGroupMember_result()
    try:
      result.success = self._handler.deleteGroupMember(args.token, args.groupId, args.emails)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("deleteGroupMember", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroupMemberByGroupId(self, seqid, iprot, oprot):
    args = getGroupMemberByGroupId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroupMemberByGroupId_result()
    try:
      result.success = self._handler.getGroupMemberByGroupId(args.token, args.groupId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("getGroupMemberByGroupId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shareDeviceToUsers(self, seqid, iprot, oprot):
    args = shareDeviceToUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shareDeviceToUsers_result()
    try:
      result.success = self._handler.shareDeviceToUsers(args.token, args.deviceId, args.sharingList, args.shareUrl)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("shareDeviceToUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateDeviceSharing(self, seqid, iprot, oprot):
    args = updateDeviceSharing_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateDeviceSharing_result()
    try:
      result.success = self._handler.updateDeviceSharing(args.token, args.deviceId, args.sharingList)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("updateDeviceSharing", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shareDeviceToGroups(self, seqid, iprot, oprot):
    args = shareDeviceToGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shareDeviceToGroups_result()
    try:
      result.success = self._handler.shareDeviceToGroups(args.token, args.deviceId, args.groupIds, args.shareUrl)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    except InvalidOperationException, iope:
      result.iope = iope
    oprot.writeMessageBegin("shareDeviceToGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revokeSharingDevice(self, seqid, iprot, oprot):
    args = revokeSharingDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revokeSharingDevice_result()
    try:
      result.success = self._handler.revokeSharingDevice(args.token, args.deviceId, args.emails)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("revokeSharingDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendEmailToCreateAccount(self, seqid, iprot, oprot):
    args = sendEmailToCreateAccount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendEmailToCreateAccount_result()
    try:
      result.success = self._handler.sendEmailToCreateAccount(args.token, args.email)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("sendEmailToCreateAccount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSharingList(self, seqid, iprot, oprot):
    args = getSharingList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSharingList_result()
    try:
      result.success = self._handler.getSharingList(args.token, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("getSharingList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setSharingDevice(self, seqid, iprot, oprot):
    args = setSharingDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setSharingDevice_result()
    try:
      result.success = self._handler.setSharingDevice(args.token, args.deviceId, args.sharable)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("setSharingDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPendingDeviceList(self, seqid, iprot, oprot):
    args = getPendingDeviceList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPendingDeviceList_result()
    try:
      result.success = self._handler.getPendingDeviceList(args.token)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("getPendingDeviceList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acceptSharingDevice(self, seqid, iprot, oprot):
    args = acceptSharingDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acceptSharingDevice_result()
    try:
      result.success = self._handler.acceptSharingDevice(args.token, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    oprot.writeMessageBegin("acceptSharingDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteSharingDevice(self, seqid, iprot, oprot):
    args = deleteSharingDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteSharingDevice_result()
    try:
      result.success = self._handler.deleteSharingDevice(args.token, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    oprot.writeMessageBegin("deleteSharingDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resendDeviceSharing(self, seqid, iprot, oprot):
    args = resendDeviceSharing_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resendDeviceSharing_result()
    try:
      result.success = self._handler.resendDeviceSharing(args.token, args.deviceId, args.shareeEmails, args.shareUrl)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("resendDeviceSharing", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findRecords(self, seqid, iprot, oprot):
    args = findRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findRecords_result()
    try:
      result.success = self._handler.findRecords(args.token, args.startTime, args.endTime, args.mydlinkId, args.trigger, args.keyword)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("findRecords", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDeviceByDeviceId(self, seqid, iprot, oprot):
    args = getDeviceByDeviceId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDeviceByDeviceId_result()
    result.success = self._handler.getDeviceByDeviceId(args.deviceId)
    oprot.writeMessageBegin("getDeviceByDeviceId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserByEmail(self, seqid, iprot, oprot):
    args = getUserByEmail_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserByEmail_result()
    result.success = self._handler.getUserByEmail(args.email)
    oprot.writeMessageBegin("getUserByEmail", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserByUserId(self, seqid, iprot, oprot):
    args = getUserByUserId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserByUserId_result()
    result.success = self._handler.getUserByUserId(args.userId)
    oprot.writeMessageBegin("getUserByUserId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendEventNotification(self, seqid, iprot, oprot):
    args = sendEventNotification_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendEventNotification_result()
    try:
      result.success = self._handler.sendEventNotification(args.deviceEventNotification)
    except InvalidDeviceException, ide:
      result.ide = ide
    oprot.writeMessageBegin("sendEventNotification", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_searchDeviceEventLog(self, seqid, iprot, oprot):
    args = searchDeviceEventLog_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = searchDeviceEventLog_result()
    try:
      result.success = self._handler.searchDeviceEventLog(args.token, args.deviceId, args.severities, args.startTime, args.endTime, args.total)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("searchDeviceEventLog", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ackAlarm(self, seqid, iprot, oprot):
    args = ackAlarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ackAlarm_result()
    try:
      result.success = self._handler.ackAlarm(args.token, args.deviceId, args.startTime, args.endTime)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("ackAlarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUnreadAlarms(self, seqid, iprot, oprot):
    args = getUnreadAlarms_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUnreadAlarms_result()
    try:
      result.success = self._handler.getUnreadAlarms(args.token, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("getUnreadAlarms", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNotificationSetting(self, seqid, iprot, oprot):
    args = getNotificationSetting_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNotificationSetting_result()
    try:
      result.success = self._handler.getNotificationSetting(args.token, args.deviceId)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    except InvalidDeviceException, ide:
      result.ide = ide
    except InvalidOwnerException, ioe:
      result.ioe = ioe
    oprot.writeMessageBegin("getNotificationSetting", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_registerMobileToken(self, seqid, iprot, oprot):
    args = registerMobileToken_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = registerMobileToken_result()
    try:
      result.success = self._handler.registerMobileToken(args.token, args.mobileToken, args.displayName, args.mobileType)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("registerMobileToken", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeMobileToken(self, seqid, iprot, oprot):
    args = removeMobileToken_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeMobileToken_result()
    try:
      result.success = self._handler.removeMobileToken(args.appToken, args.mobileTokens)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("removeMobileToken", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listMobileToken(self, seqid, iprot, oprot):
    args = listMobileToken_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listMobileToken_result()
    try:
      result.success = self._handler.listMobileToken(args.accessToken)
    except InvalidAccessTokenException, iae:
      result.iae = iae
    oprot.writeMessageBegin("listMobileToken", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendTxtMsgToGsenderQueue(self, seqid, iprot, oprot):
    args = sendTxtMsgToGsenderQueue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendTxtMsgToGsenderQueue_result()
    result.success = self._handler.sendTxtMsgToGsenderQueue(args.message)
    oprot.writeMessageBegin("sendTxtMsgToGsenderQueue", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class ping_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stop_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stop_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reload_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reload_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reload_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reload_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isAppRegistered_args(object):
  """
  Attributes:
   - appId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'appId', None, None, ), # 1
  )

  def __init__(self, appId=None,):
    self.appId = appId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.appId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isAppRegistered_args')
    if self.appId is not None:
      oprot.writeFieldBegin('appId', TType.STRING, 1)
      oprot.writeString(self.appId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isAppRegistered_result(object):
  """
  Attributes:
   - success
   - ue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ue', (UnknownAppException, UnknownAppException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ue=None,):
    self.success = success
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ue = UnknownAppException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isAppRegistered_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 1)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenApp_args(object):
  """
  Attributes:
   - app
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'app', (Application, Application.thrift_spec), None, ), # 1
  )

  def __init__(self, app=None,):
    self.app = app

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.app = Application()
          self.app.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenApp_args')
    if self.app is not None:
      oprot.writeFieldBegin('app', TType.STRUCT, 1)
      self.app.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenApp_result(object):
  """
  Attributes:
   - success
   - iae
   - ue
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAppException, InvalidAppException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (UnknownAppException, UnknownAppException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, iae=None, ue=None,):
    self.success = success
    self.iae = iae
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAppException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = UnknownAppException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenApp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authApp_args(object):
  """
  Attributes:
   - appId
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'appId', None, None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, appId=None, user=None,):
    self.appId = appId
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.appId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authApp_args')
    if self.appId is not None:
      oprot.writeFieldBegin('appId', TType.STRING, 1)
      oprot.writeString(self.appId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authApp_result(object):
  """
  Attributes:
   - success
   - iae
   - ie
   - uue
   - ue
   - ise
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthResponse, AuthResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (UnknownAppException, UnknownAppException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ie', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'uue', (UnknownUserException, UnknownUserException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'ise', (IncorrectSiteException, IncorrectSiteException.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, iae=None, ie=None, uue=None, ue=None, ise=None,):
    self.success = success
    self.iae = iae
    self.ie = ie
    self.uue = uue
    self.ue = ue
    self.ise = ise

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = UnknownAppException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ie = InvalidUserException()
          self.ie.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.uue = UnknownUserException()
          self.uue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ise = IncorrectSiteException()
          self.ise.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authApp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ie is not None:
      oprot.writeFieldBegin('ie', TType.STRUCT, 2)
      self.ie.write(oprot)
      oprot.writeFieldEnd()
    if self.uue is not None:
      oprot.writeFieldBegin('uue', TType.STRUCT, 3)
      self.uue.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 4)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    if self.ise is not None:
      oprot.writeFieldBegin('ise', TType.STRUCT, 5)
      self.ise.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unauthApp_args(object):
  """
  Attributes:
   - appId
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'appId', None, None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, appId=None, user=None,):
    self.appId = appId
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.appId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unauthApp_args')
    if self.appId is not None:
      oprot.writeFieldBegin('appId', TType.STRING, 1)
      oprot.writeString(self.appId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unauthApp_result(object):
  """
  Attributes:
   - success
   - ie
   - uue
   - uae
   - ue
   - ise
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ie', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'uue', (UnknownUserException, UnknownUserException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'uae', (UnknownAppException, UnknownAppException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'ise', (IncorrectSiteException, IncorrectSiteException.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, ie=None, uue=None, uae=None, ue=None, ise=None,):
    self.success = success
    self.ie = ie
    self.uue = uue
    self.uae = uae
    self.ue = ue
    self.ise = ise

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ie = InvalidUserException()
          self.ie.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.uue = UnknownUserException()
          self.uue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.uae = UnknownAppException()
          self.uae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ise = IncorrectSiteException()
          self.ise.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unauthApp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ie is not None:
      oprot.writeFieldBegin('ie', TType.STRUCT, 1)
      self.ie.write(oprot)
      oprot.writeFieldEnd()
    if self.uue is not None:
      oprot.writeFieldBegin('uue', TType.STRUCT, 2)
      self.uue.write(oprot)
      oprot.writeFieldEnd()
    if self.uae is not None:
      oprot.writeFieldBegin('uae', TType.STRUCT, 3)
      self.uae.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 4)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    if self.ise is not None:
      oprot.writeFieldBegin('ise', TType.STRUCT, 5)
      self.ise.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grantApp_args(object):
  """
  Attributes:
   - authCode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'authCode', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, authCode=None,):
    self.authCode = authCode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.authCode = AccessToken()
          self.authCode.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grantApp_args')
    if self.authCode is not None:
      oprot.writeFieldBegin('authCode', TType.STRUCT, 1)
      self.authCode.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grantApp_result(object):
  """
  Attributes:
   - success
   - ie
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ie', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ie=None,):
    self.success = success
    self.ie = ie

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ie = InvalidOperationException()
          self.ie.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grantApp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ie is not None:
      oprot.writeFieldBegin('ie', TType.STRUCT, 1)
      self.ie.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAccessToken_args(object):
  """
  Attributes:
   - accessToken
   - app
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'app', (AppAuthenInfo, AppAuthenInfo.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, app=None,):
    self.accessToken = accessToken
    self.app = app

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.app = AppAuthenInfo()
          self.app.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAccessToken_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.app is not None:
      oprot.writeFieldBegin('app', TType.STRUCT, 2)
      self.app.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAccessToken_result(object):
  """
  Attributes:
   - success
   - ie
   - ue
   - iae
   - dte
   - ite
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ie', (InvalidAppException, InvalidAppException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (UnknownAppException, UnknownAppException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'iae', (InvalidAuthCodeException, InvalidAuthCodeException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'dte', (DuplicateTimestampException, DuplicateTimestampException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'ite', (InvalidTimestampException, InvalidTimestampException.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, ie=None, ue=None, iae=None, dte=None, ite=None,):
    self.success = success
    self.ie = ie
    self.ue = ue
    self.iae = iae
    self.dte = dte
    self.ite = ite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ie = InvalidAppException()
          self.ie.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = UnknownAppException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.iae = InvalidAuthCodeException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.dte = DuplicateTimestampException()
          self.dte.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ite = InvalidTimestampException()
          self.ite.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAccessToken_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ie is not None:
      oprot.writeFieldBegin('ie', TType.STRUCT, 1)
      self.ie.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 3)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.dte is not None:
      oprot.writeFieldBegin('dte', TType.STRUCT, 4)
      self.dte.write(oprot)
      oprot.writeFieldEnd()
    if self.ite is not None:
      oprot.writeFieldBegin('ite', TType.STRUCT, 5)
      self.ite.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renewAccessToken_args(object):
  """
  Attributes:
   - accessToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, accessToken=None,):
    self.accessToken = accessToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renewAccessToken_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renewAccessToken_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renewAccessToken_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerUser_args(object):
  """
  Attributes:
   - appToken
   - user
   - confirmUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
    (3, TType.STRING, 'confirmUrl', None, None, ), # 3
  )

  def __init__(self, appToken=None, user=None, confirmUrl=None,):
    self.appToken = appToken
    self.user = user
    self.confirmUrl = confirmUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.confirmUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerUser_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    if self.confirmUrl is not None:
      oprot.writeFieldBegin('confirmUrl', TType.STRING, 3)
      oprot.writeString(self.confirmUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerUser_result(object):
  """
  Attributes:
   - success
   - eue
   - ioe
   - ipe
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'eue', (ExistedEntityException, ExistedEntityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ipe', (InvalidParamException, InvalidParamException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, eue=None, ioe=None, ipe=None,):
    self.success = success
    self.eue = eue
    self.ioe = ioe
    self.ipe = ipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.eue = ExistedEntityException()
          self.eue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ipe = InvalidParamException()
          self.ipe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.eue is not None:
      oprot.writeFieldBegin('eue', TType.STRUCT, 1)
      self.eue.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ipe is not None:
      oprot.writeFieldBegin('ipe', TType.STRUCT, 3)
      self.ipe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createUser_args(object):
  """
  Attributes:
   - appToken
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, appToken=None, user=None,):
    self.appToken = appToken
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createUser_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createUser_result(object):
  """
  Attributes:
   - success
   - eue
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'eue', (ExistedEntityException, ExistedEntityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, eue=None, ioe=None,):
    self.success = success
    self.eue = eue
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.eue = ExistedEntityException()
          self.eue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.eue is not None:
      oprot.writeFieldBegin('eue', TType.STRUCT, 1)
      self.eue.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUserByApp_args(object):
  """
  Attributes:
   - appToken
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, appToken=None, user=None,):
    self.appToken = appToken
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUserByApp_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUserByApp_result(object):
  """
  Attributes:
   - success
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ioe=None,):
    self.success = success
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUserByApp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class forgetPasswd_args(object):
  """
  Attributes:
   - appToken
   - user
   - url
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
    (3, TType.STRING, 'url', None, None, ), # 3
  )

  def __init__(self, appToken=None, user=None, url=None,):
    self.appToken = appToken
    self.user = user
    self.url = url

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.url = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('forgetPasswd_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 3)
      oprot.writeString(self.url.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class forgetPasswd_result(object):
  """
  Attributes:
   - success
   - ioe
   - ue
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (UnknownUserException, UnknownUserException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ioe=None, ue=None,):
    self.success = success
    self.ioe = ioe
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = UnknownUserException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('forgetPasswd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resetPasswd_args(object):
  """
  Attributes:
   - passwdKey
   - newPasswd
   - email
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'passwdKey', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'newPasswd', None, None, ), # 2
    (3, TType.STRING, 'email', None, None, ), # 3
  )

  def __init__(self, passwdKey=None, newPasswd=None, email=None,):
    self.passwdKey = passwdKey
    self.newPasswd = newPasswd
    self.email = email

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.passwdKey = AccessToken()
          self.passwdKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.newPasswd = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resetPasswd_args')
    if self.passwdKey is not None:
      oprot.writeFieldBegin('passwdKey', TType.STRUCT, 1)
      self.passwdKey.write(oprot)
      oprot.writeFieldEnd()
    if self.newPasswd is not None:
      oprot.writeFieldBegin('newPasswd', TType.STRING, 2)
      oprot.writeString(self.newPasswd.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 3)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resetPasswd_result(object):
  """
  Attributes:
   - success
   - ioe
   - uue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'uue', (UnknownUserException, UnknownUserException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ioe=None, uue=None,):
    self.success = success
    self.ioe = ioe
    self.uue = uue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.uue = UnknownUserException()
          self.uue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resetPasswd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.uue is not None:
      oprot.writeFieldBegin('uue', TType.STRUCT, 2)
      self.uue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieveUser_args(object):
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieveUser_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieveUser_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (User, User.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieveUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieveUserProfile_args(object):
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieveUserProfile_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieveUserProfile_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (User, User.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieveUserProfile_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateUser_args(object):
  """
  Attributes:
   - token
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, token=None, user=None,):
    self.token = token
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateUser_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateUser_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUser_args(object):
  """
  Attributes:
   - token
   - userPasswd
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'userPasswd', None, None, ), # 2
  )

  def __init__(self, token=None, userPasswd=None,):
    self.token = token
    self.userPasswd = userPasswd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userPasswd = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUser_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.userPasswd is not None:
      oprot.writeFieldBegin('userPasswd', TType.STRING, 2)
      oprot.writeString(self.userPasswd.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUser_result(object):
  """
  Attributes:
   - success
   - iae
   - ie
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ie', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ie=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ie = ie
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ie = InvalidUserException()
          self.ie.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOperationException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ie is not None:
      oprot.writeFieldBegin('ie', TType.STRUCT, 2)
      self.ie.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeEmail_args(object):
  """
  Attributes:
   - token
   - userPasswd
   - newEmail
   - confirmUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'userPasswd', None, None, ), # 2
    (3, TType.STRING, 'newEmail', None, None, ), # 3
    (4, TType.STRING, 'confirmUrl', None, None, ), # 4
  )

  def __init__(self, token=None, userPasswd=None, newEmail=None, confirmUrl=None,):
    self.token = token
    self.userPasswd = userPasswd
    self.newEmail = newEmail
    self.confirmUrl = confirmUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userPasswd = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.newEmail = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.confirmUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeEmail_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.userPasswd is not None:
      oprot.writeFieldBegin('userPasswd', TType.STRING, 2)
      oprot.writeString(self.userPasswd.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.newEmail is not None:
      oprot.writeFieldBegin('newEmail', TType.STRING, 3)
      oprot.writeString(self.newEmail.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.confirmUrl is not None:
      oprot.writeFieldBegin('confirmUrl', TType.STRING, 4)
      oprot.writeString(self.confirmUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeEmail_result(object):
  """
  Attributes:
   - success
   - ioe
   - ie
   - eue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ie', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'eue', (ExistedEntityException, ExistedEntityException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ioe=None, ie=None, eue=None,):
    self.success = success
    self.ioe = ioe
    self.ie = ie
    self.eue = eue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ie = InvalidUserException()
          self.ie.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.eue = ExistedEntityException()
          self.eue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeEmail_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ie is not None:
      oprot.writeFieldBegin('ie', TType.STRUCT, 2)
      self.ie.write(oprot)
      oprot.writeFieldEnd()
    if self.eue is not None:
      oprot.writeFieldBegin('eue', TType.STRUCT, 3)
      self.eue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changePasswd_args(object):
  """
  Attributes:
   - token
   - oldPasswd
   - newPasswd
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'oldPasswd', None, None, ), # 2
    (3, TType.STRING, 'newPasswd', None, None, ), # 3
  )

  def __init__(self, token=None, oldPasswd=None, newPasswd=None,):
    self.token = token
    self.oldPasswd = oldPasswd
    self.newPasswd = newPasswd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.oldPasswd = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.newPasswd = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changePasswd_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.oldPasswd is not None:
      oprot.writeFieldBegin('oldPasswd', TType.STRING, 2)
      oprot.writeString(self.oldPasswd.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.newPasswd is not None:
      oprot.writeFieldBegin('newPasswd', TType.STRING, 3)
      oprot.writeString(self.newPasswd.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changePasswd_result(object):
  """
  Attributes:
   - success
   - ioe
   - ue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ioe=None, ue=None,):
    self.success = success
    self.ioe = ioe
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = InvalidUserException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changePasswd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class confirmUser_args(object):
  """
  Attributes:
   - email
   - confirmKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'email', None, None, ), # 1
    (2, TType.STRING, 'confirmKey', None, None, ), # 2
  )

  def __init__(self, email=None, confirmKey=None,):
    self.email = email
    self.confirmKey = confirmKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.confirmKey = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('confirmUser_args')
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 1)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.confirmKey is not None:
      oprot.writeFieldBegin('confirmKey', TType.STRING, 2)
      oprot.writeString(self.confirmKey.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class confirmUser_result(object):
  """
  Attributes:
   - success
   - ioe
   - ue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (InvalidUserException, InvalidUserException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ioe=None, ue=None,):
    self.success = success
    self.ioe = ioe
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = InvalidUserException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('confirmUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resendConfirmKey_args(object):
  """
  Attributes:
   - token
   - confirmUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'confirmUrl', None, None, ), # 2
  )

  def __init__(self, token=None, confirmUrl=None,):
    self.token = token
    self.confirmUrl = confirmUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.confirmUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resendConfirmKey_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.confirmUrl is not None:
      oprot.writeFieldBegin('confirmUrl', TType.STRING, 2)
      oprot.writeString(self.confirmUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resendConfirmKey_result(object):
  """
  Attributes:
   - success
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ioe=None,):
    self.success = success
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidAccessTokenException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resendConfirmKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bindDevice_args(object):
  """
  Attributes:
   - accessToken
   - deviceId
   - accessKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessKey', None, None, ), # 3
  )

  def __init__(self, accessToken=None, deviceId=None, accessKey=None,):
    self.accessToken = accessToken
    self.deviceId = deviceId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bindDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 3)
      oprot.writeString(self.accessKey.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bindDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
   - ipe
   - ue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ipe', (InvalidParamException, InvalidParamException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None, ipe=None, ue=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe
    self.ipe = ipe
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ipe = InvalidParamException()
          self.ipe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bindDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ipe is not None:
      oprot.writeFieldBegin('ipe', TType.STRUCT, 4)
      self.ipe.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 5)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unbindDevice_args(object):
  """
  Attributes:
   - accessToken
   - deviceId
   - userPasswd
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.STRING, 'userPasswd', None, None, ), # 3
  )

  def __init__(self, accessToken=None, deviceId=None, userPasswd=None,):
    self.accessToken = accessToken
    self.deviceId = deviceId
    self.userPasswd = userPasswd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userPasswd = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unbindDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.userPasswd is not None:
      oprot.writeFieldBegin('userPasswd', TType.STRING, 3)
      oprot.writeString(self.userPasswd.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unbindDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ue
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ue', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ue=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ue = InvalidOwnerException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unbindDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 3)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class validateDeviceAccess_args(object):
  """
  Attributes:
   - accessToken
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, deviceId=None,):
    self.accessToken = accessToken
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('validateDeviceAccess_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class validateDeviceAccess_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('validateDeviceAccess_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDeviceListByAccessToken_args(object):
  """
  Attributes:
   - accessToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, accessToken=None,):
    self.accessToken = accessToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeviceListByAccessToken_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDeviceListByAccessToken_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Device, Device.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = Device()
            _elem21.read(iprot)
            self.success.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeviceListByAccessToken_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter22 in self.success:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSldNameByDeviceId_args(object):
  """
  Attributes:
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
  )

  def __init__(self, deviceId=None,):
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSldNameByDeviceId_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSldNameByDeviceId_result(object):
  """
  Attributes:
   - success
   - ioe
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ioe', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ioe=None,):
    self.success = success
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOperationException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSldNameByDeviceId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class publishDevice_args(object):
  """
  Attributes:
   - accessToken
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'device', (Device, Device.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, device=None,):
    self.accessToken = accessToken
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('publishDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.STRUCT, 2)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class publishDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('publishDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancelPublicDevice_args(object):
  """
  Attributes:
   - accessToken
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, deviceId=None,):
    self.accessToken = accessToken
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancelPublicDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancelPublicDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancelPublicDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDevice_args(object):
  """
  Attributes:
   - accessToken
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'device', (Device, Device.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, device=None,):
    self.accessToken = accessToken
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.STRUCT, 2)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicDeviceById_args(object):
  """
  Attributes:
   - appToken
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, appToken=None, deviceId=None,):
    self.appToken = appToken
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicDeviceById_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicDeviceById_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, iae=None, ide=None,):
    self.success = success
    self.iae = iae
    self.ide = ide

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicDeviceById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopPublicDevice_args(object):
  """
  Attributes:
   - appToken
   - topNumber
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'topNumber', None, None, ), # 2
  )

  def __init__(self, appToken=None, topNumber=None,):
    self.appToken = appToken
    self.topNumber = topNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.topNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopPublicDevice_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.topNumber is not None:
      oprot.writeFieldBegin('topNumber', TType.I32, 2)
      oprot.writeI32(self.topNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopPublicDevice_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Device, Device.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = Device()
            _elem28.read(iprot)
            self.success.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopPublicDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter29 in self.success:
        iter29.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchPublicDevice_args(object):
  """
  Attributes:
   - appToken
   - center
   - range
   - maximum
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'center', (Location, Location.thrift_spec), None, ), # 2
    (3, TType.DOUBLE, 'range', None, None, ), # 3
    (4, TType.I32, 'maximum', None, None, ), # 4
  )

  def __init__(self, appToken=None, center=None, range=None, maximum=None,):
    self.appToken = appToken
    self.center = center
    self.range = range
    self.maximum = maximum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.center = Location()
          self.center.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.range = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maximum = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchPublicDevice_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.center is not None:
      oprot.writeFieldBegin('center', TType.STRUCT, 2)
      self.center.write(oprot)
      oprot.writeFieldEnd()
    if self.range is not None:
      oprot.writeFieldBegin('range', TType.DOUBLE, 3)
      oprot.writeDouble(self.range)
      oprot.writeFieldEnd()
    if self.maximum is not None:
      oprot.writeFieldBegin('maximum', TType.I32, 4)
      oprot.writeI32(self.maximum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchPublicDevice_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Device, Device.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = Device()
            _elem35.read(iprot)
            self.success.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchPublicDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter36 in self.success:
        iter36.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addFavoriteDevice_args(object):
  """
  Attributes:
   - accessToken
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, deviceId=None,):
    self.accessToken = accessToken
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addFavoriteDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addFavoriteDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOperationException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addFavoriteDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeFavoriteDevice_args(object):
  """
  Attributes:
   - accessToken
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, deviceId=None,):
    self.accessToken = accessToken
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeFavoriteDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeFavoriteDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOperationException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeFavoriteDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFavoriteDevice_args(object):
  """
  Attributes:
   - accessToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, accessToken=None,):
    self.accessToken = accessToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFavoriteDevice_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFavoriteDevice_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Device, Device.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype40, _size37) = iprot.readListBegin()
          for _i41 in xrange(_size37):
            _elem42 = Device()
            _elem42.read(iprot)
            self.success.append(_elem42)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFavoriteDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter43 in self.success:
        iter43.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deviceConnReq_args(object):
  """
  Attributes:
   - accessToken
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'req', (DeviceConnRequest, DeviceConnRequest.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, req=None,):
    self.accessToken = accessToken
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.req = DeviceConnRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceConnReq_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 2)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deviceConnReq_result(object):
  """
  Attributes:
   - success
   - iae
   - ioe
   - ue
   - te
   - idc
   - ide
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DeviceConnResponse, DeviceConnResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'te', (TimedOutException, TimedOutException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'idc', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'ide', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, iae=None, ioe=None, ue=None, te=None, idc=None, ide=None,):
    self.success = success
    self.iae = iae
    self.ioe = ioe
    self.ue = ue
    self.te = te
    self.idc = idc
    self.ide = ide

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DeviceConnResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOperationException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.te = TimedOutException()
          self.te.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.idc = InvalidDeviceException()
          self.idc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.ide = InvalidOwnerException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deviceConnReq_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 3)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    if self.te is not None:
      oprot.writeFieldBegin('te', TType.STRUCT, 4)
      self.te.write(oprot)
      oprot.writeFieldEnd()
    if self.idc is not None:
      oprot.writeFieldBegin('idc', TType.STRUCT, 5)
      self.idc.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 6)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pubDeviceConnReq_args(object):
  """
  Attributes:
   - accessToken
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'req', (DeviceConnRequest, DeviceConnRequest.thrift_spec), None, ), # 2
  )

  def __init__(self, accessToken=None, req=None,):
    self.accessToken = accessToken
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.req = DeviceConnRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pubDeviceConnReq_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 2)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pubDeviceConnReq_result(object):
  """
  Attributes:
   - success
   - iae
   - ioe
   - ue
   - te
   - idc
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DeviceConnResponse, DeviceConnResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'te', (TimedOutException, TimedOutException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'idc', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, iae=None, ioe=None, ue=None, te=None, idc=None,):
    self.success = success
    self.iae = iae
    self.ioe = ioe
    self.ue = ue
    self.te = te
    self.idc = idc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DeviceConnResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOperationException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.te = TimedOutException()
          self.te.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.idc = InvalidDeviceException()
          self.idc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pubDeviceConnReq_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ue is not None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 3)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    if self.te is not None:
      oprot.writeFieldBegin('te', TType.STRUCT, 4)
      self.te.write(oprot)
      oprot.writeFieldEnd()
    if self.idc is not None:
      oprot.writeFieldBegin('idc', TType.STRUCT, 5)
      self.idc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateRecordingMeta_args(object):
  """
  Attributes:
   - deviceId
   - metaInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
    (2, TType.STRING, 'metaInfo', None, None, ), # 2
  )

  def __init__(self, deviceId=None, metaInfo=None,):
    self.deviceId = deviceId
    self.metaInfo = metaInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.metaInfo = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateRecordingMeta_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.metaInfo is not None:
      oprot.writeFieldBegin('metaInfo', TType.STRING, 2)
      oprot.writeString(self.metaInfo.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateRecordingMeta_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateRecordingMeta_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addGroup_args(object):
  """
  Attributes:
   - token
   - groupName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'groupName', None, None, ), # 2
  )

  def __init__(self, token=None, groupName=None,):
    self.token = token
    self.groupName = groupName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addGroup_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupName is not None:
      oprot.writeFieldBegin('groupName', TType.STRING, 2)
      oprot.writeString(self.groupName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addGroup_result(object):
  """
  Attributes:
   - success
   - iae
   - eue
   - ivp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GroupTitle, GroupTitle.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'eue', (ExistedEntityException, ExistedEntityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ivp', (InvalidParamException, InvalidParamException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, eue=None, ivp=None,):
    self.success = success
    self.iae = iae
    self.eue = eue
    self.ivp = ivp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GroupTitle()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.eue = ExistedEntityException()
          self.eue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ivp = InvalidParamException()
          self.ivp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.eue is not None:
      oprot.writeFieldBegin('eue', TType.STRUCT, 2)
      self.eue.write(oprot)
      oprot.writeFieldEnd()
    if self.ivp is not None:
      oprot.writeFieldBegin('ivp', TType.STRUCT, 3)
      self.ivp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyGroup_args(object):
  """
  Attributes:
   - token
   - groupTitle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'groupTitle', (GroupTitle, GroupTitle.thrift_spec), None, ), # 2
  )

  def __init__(self, token=None, groupTitle=None,):
    self.token = token
    self.groupTitle = groupTitle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.groupTitle = GroupTitle()
          self.groupTitle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyGroup_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupTitle is not None:
      oprot.writeFieldBegin('groupTitle', TType.STRUCT, 2)
      self.groupTitle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyGroup_result(object):
  """
  Attributes:
   - success
   - iae
   - eue
   - ioe
   - ivp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'eue', (ExistedEntityException, ExistedEntityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ivp', (InvalidParamException, InvalidParamException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, iae=None, eue=None, ioe=None, ivp=None,):
    self.success = success
    self.iae = iae
    self.eue = eue
    self.ioe = ioe
    self.ivp = ivp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.eue = ExistedEntityException()
          self.eue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ivp = InvalidParamException()
          self.ivp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.eue is not None:
      oprot.writeFieldBegin('eue', TType.STRUCT, 2)
      self.eue.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ivp is not None:
      oprot.writeFieldBegin('ivp', TType.STRUCT, 4)
      self.ivp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGroup_args(object):
  """
  Attributes:
   - token
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'groupId', None, None, ), # 2
  )

  def __init__(self, token=None, groupId=None,):
    self.token = token
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.groupId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGroup_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.I32, 2)
      oprot.writeI32(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGroup_result(object):
  """
  Attributes:
   - success
   - iae
   - eue
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'eue', (ExistedEntityException, ExistedEntityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, eue=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.eue = eue
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.eue = ExistedEntityException()
          self.eue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.eue is not None:
      oprot.writeFieldBegin('eue', TType.STRUCT, 2)
      self.eue.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupTitleByGroupId_args(object):
  """
  Attributes:
   - token
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'groupId', None, None, ), # 2
  )

  def __init__(self, token=None, groupId=None,):
    self.token = token
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.groupId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupTitleByGroupId_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.I32, 2)
      oprot.writeI32(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupTitleByGroupId_result(object):
  """
  Attributes:
   - success
   - iae
   - ioe
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GroupTitle, GroupTitle.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, iae=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GroupTitle()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupTitleByGroupId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupList_args(object):
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupList_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupList_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(GroupTitle, GroupTitle.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype47, _size44) = iprot.readListBegin()
          for _i48 in xrange(_size44):
            _elem49 = GroupTitle()
            _elem49.read(iprot)
            self.success.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter50 in self.success:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addGroupMember_args(object):
  """
  Attributes:
   - token
   - groupId
   - contacts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'groupId', None, None, ), # 2
    (3, TType.LIST, 'contacts', (TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 3
  )

  def __init__(self, token=None, groupId=None, contacts=None,):
    self.token = token
    self.groupId = groupId
    self.contacts = contacts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.groupId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contacts = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = Contact()
            _elem56.read(iprot)
            self.contacts.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addGroupMember_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.I32, 2)
      oprot.writeI32(self.groupId)
      oprot.writeFieldEnd()
    if self.contacts is not None:
      oprot.writeFieldBegin('contacts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.contacts))
      for iter57 in self.contacts:
        iter57.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addGroupMember_result(object):
  """
  Attributes:
   - success
   - iae
   - ioe
   - ivp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ivp', (InvalidParamException, InvalidParamException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ioe=None, ivp=None,):
    self.success = success
    self.iae = iae
    self.ioe = ioe
    self.ivp = ivp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ivp = InvalidParamException()
          self.ivp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addGroupMember_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ivp is not None:
      oprot.writeFieldBegin('ivp', TType.STRUCT, 3)
      self.ivp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateGroupMember_args(object):
  """
  Attributes:
   - token
   - groupId
   - contacts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'groupId', None, None, ), # 2
    (3, TType.LIST, 'contacts', (TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 3
  )

  def __init__(self, token=None, groupId=None, contacts=None,):
    self.token = token
    self.groupId = groupId
    self.contacts = contacts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.groupId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contacts = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = Contact()
            _elem63.read(iprot)
            self.contacts.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateGroupMember_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.I32, 2)
      oprot.writeI32(self.groupId)
      oprot.writeFieldEnd()
    if self.contacts is not None:
      oprot.writeFieldBegin('contacts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.contacts))
      for iter64 in self.contacts:
        iter64.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateGroupMember_result(object):
  """
  Attributes:
   - success
   - iae
   - ioe
   - ivp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ivp', (InvalidParamException, InvalidParamException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ioe=None, ivp=None,):
    self.success = success
    self.iae = iae
    self.ioe = ioe
    self.ivp = ivp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ivp = InvalidParamException()
          self.ivp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateGroupMember_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.ivp is not None:
      oprot.writeFieldBegin('ivp', TType.STRUCT, 3)
      self.ivp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGroupMember_args(object):
  """
  Attributes:
   - token
   - groupId
   - emails
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'groupId', None, None, ), # 2
    (3, TType.LIST, 'emails', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, groupId=None, emails=None,):
    self.token = token
    self.groupId = groupId
    self.emails = emails

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.groupId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.emails = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = iprot.readString().decode('utf-8')
            self.emails.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGroupMember_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.I32, 2)
      oprot.writeI32(self.groupId)
      oprot.writeFieldEnd()
    if self.emails is not None:
      oprot.writeFieldBegin('emails', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.emails))
      for iter71 in self.emails:
        oprot.writeString(iter71.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGroupMember_result(object):
  """
  Attributes:
   - success
   - iae
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, iae=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGroupMember_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupMemberByGroupId_args(object):
  """
  Attributes:
   - token
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'groupId', None, None, ), # 2
  )

  def __init__(self, token=None, groupId=None,):
    self.token = token
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.groupId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupMemberByGroupId_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.I32, 2)
      oprot.writeI32(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupMemberByGroupId_result(object):
  """
  Attributes:
   - success
   - iae
   - ioe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, iae=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = Contact()
            _elem77.read(iprot)
            self.success.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupMemberByGroupId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter78 in self.success:
        iter78.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 2)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareDeviceToUsers_args(object):
  """
  Attributes:
   - token
   - deviceId
   - sharingList
   - shareUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.LIST, 'sharingList', (TType.STRUCT,(DeviceSharing, DeviceSharing.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'shareUrl', None, None, ), # 4
  )

  def __init__(self, token=None, deviceId=None, sharingList=None, shareUrl=None,):
    self.token = token
    self.deviceId = deviceId
    self.sharingList = sharingList
    self.shareUrl = shareUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.sharingList = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = DeviceSharing()
            _elem84.read(iprot)
            self.sharingList.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.shareUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareDeviceToUsers_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.sharingList is not None:
      oprot.writeFieldBegin('sharingList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.sharingList))
      for iter85 in self.sharingList:
        iter85.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.shareUrl is not None:
      oprot.writeFieldBegin('shareUrl', TType.STRING, 4)
      oprot.writeString(self.shareUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareDeviceToUsers_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareDeviceToUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDeviceSharing_args(object):
  """
  Attributes:
   - token
   - deviceId
   - sharingList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.LIST, 'sharingList', (TType.STRUCT,(DeviceSharing, DeviceSharing.thrift_spec)), None, ), # 3
  )

  def __init__(self, token=None, deviceId=None, sharingList=None,):
    self.token = token
    self.deviceId = deviceId
    self.sharingList = sharingList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.sharingList = []
          (_etype89, _size86) = iprot.readListBegin()
          for _i90 in xrange(_size86):
            _elem91 = DeviceSharing()
            _elem91.read(iprot)
            self.sharingList.append(_elem91)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDeviceSharing_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.sharingList is not None:
      oprot.writeFieldBegin('sharingList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.sharingList))
      for iter92 in self.sharingList:
        iter92.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDeviceSharing_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDeviceSharing_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareDeviceToGroups_args(object):
  """
  Attributes:
   - token
   - deviceId
   - groupIds
   - shareUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.LIST, 'groupIds', (TType.I32,None), None, ), # 3
    (4, TType.STRING, 'shareUrl', None, None, ), # 4
  )

  def __init__(self, token=None, deviceId=None, groupIds=None, shareUrl=None,):
    self.token = token
    self.deviceId = deviceId
    self.groupIds = groupIds
    self.shareUrl = shareUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.groupIds = []
          (_etype96, _size93) = iprot.readListBegin()
          for _i97 in xrange(_size93):
            _elem98 = iprot.readI32();
            self.groupIds.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.shareUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareDeviceToGroups_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.groupIds is not None:
      oprot.writeFieldBegin('groupIds', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.groupIds))
      for iter99 in self.groupIds:
        oprot.writeI32(iter99)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.shareUrl is not None:
      oprot.writeFieldBegin('shareUrl', TType.STRING, 4)
      oprot.writeString(self.shareUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareDeviceToGroups_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
   - iope
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'iope', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None, iope=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe
    self.iope = iope

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.iope = InvalidOperationException()
          self.iope.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareDeviceToGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    if self.iope is not None:
      oprot.writeFieldBegin('iope', TType.STRUCT, 4)
      self.iope.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeSharingDevice_args(object):
  """
  Attributes:
   - token
   - deviceId
   - emails
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.LIST, 'emails', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, deviceId=None, emails=None,):
    self.token = token
    self.deviceId = deviceId
    self.emails = emails

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.emails = []
          (_etype103, _size100) = iprot.readListBegin()
          for _i104 in xrange(_size100):
            _elem105 = iprot.readString().decode('utf-8')
            self.emails.append(_elem105)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeSharingDevice_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.emails is not None:
      oprot.writeFieldBegin('emails', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.emails))
      for iter106 in self.emails:
        oprot.writeString(iter106.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeSharingDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeSharingDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendEmailToCreateAccount_args(object):
  """
  Attributes:
   - token
   - email
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'email', None, None, ), # 2
  )

  def __init__(self, token=None, email=None,):
    self.token = token
    self.email = email

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendEmailToCreateAccount_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 2)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendEmailToCreateAccount_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendEmailToCreateAccount_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSharingList_args(object):
  """
  Attributes:
   - token
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, token=None, deviceId=None,):
    self.token = token
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSharingList_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSharingList_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(DeviceSharing, DeviceSharing.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = DeviceSharing()
            _elem112.read(iprot)
            self.success.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSharingList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter113 in self.success:
        iter113.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSharingDevice_args(object):
  """
  Attributes:
   - token
   - deviceId
   - sharable
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'sharable', None, None, ), # 3
  )

  def __init__(self, token=None, deviceId=None, sharable=None,):
    self.token = token
    self.deviceId = deviceId
    self.sharable = sharable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.sharable = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSharingDevice_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.sharable is not None:
      oprot.writeFieldBegin('sharable', TType.BOOL, 3)
      oprot.writeBool(self.sharable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSharingDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSharingDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPendingDeviceList_args(object):
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPendingDeviceList_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPendingDeviceList_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SharedDevice, SharedDevice.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = SharedDevice()
            _elem119.read(iprot)
            self.success.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPendingDeviceList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter120 in self.success:
        iter120.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acceptSharingDevice_args(object):
  """
  Attributes:
   - token
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, token=None, deviceId=None,):
    self.token = token
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acceptSharingDevice_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acceptSharingDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, iae=None, ide=None,):
    self.success = success
    self.iae = iae
    self.ide = ide

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acceptSharingDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteSharingDevice_args(object):
  """
  Attributes:
   - token
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, token=None, deviceId=None,):
    self.token = token
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteSharingDevice_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteSharingDevice_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, iae=None, ide=None,):
    self.success = success
    self.iae = iae
    self.ide = ide

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteSharingDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resendDeviceSharing_args(object):
  """
  Attributes:
   - token
   - deviceId
   - shareeEmails
   - shareUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.LIST, 'shareeEmails', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'shareUrl', None, None, ), # 4
  )

  def __init__(self, token=None, deviceId=None, shareeEmails=None, shareUrl=None,):
    self.token = token
    self.deviceId = deviceId
    self.shareeEmails = shareeEmails
    self.shareUrl = shareUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.shareeEmails = []
          (_etype124, _size121) = iprot.readListBegin()
          for _i125 in xrange(_size121):
            _elem126 = iprot.readString().decode('utf-8')
            self.shareeEmails.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.shareUrl = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resendDeviceSharing_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.shareeEmails is not None:
      oprot.writeFieldBegin('shareeEmails', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.shareeEmails))
      for iter127 in self.shareeEmails:
        oprot.writeString(iter127.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.shareUrl is not None:
      oprot.writeFieldBegin('shareUrl', TType.STRING, 4)
      oprot.writeString(self.shareUrl.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resendDeviceSharing_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resendDeviceSharing_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findRecords_args(object):
  """
  Attributes:
   - token
   - startTime
   - endTime
   - mydlinkId
   - trigger
   - keyword
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'startTime', None, None, ), # 2
    (3, TType.I64, 'endTime', None, None, ), # 3
    (4, TType.STRING, 'mydlinkId', None, None, ), # 4
    (5, TType.STRING, 'trigger', None, None, ), # 5
    (6, TType.STRING, 'keyword', None, None, ), # 6
  )

  def __init__(self, token=None, startTime=None, endTime=None, mydlinkId=None, trigger=None, keyword=None,):
    self.token = token
    self.startTime = startTime
    self.endTime = endTime
    self.mydlinkId = mydlinkId
    self.trigger = trigger
    self.keyword = keyword

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.endTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.mydlinkId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.trigger = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.keyword = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findRecords_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 2)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 3)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    if self.mydlinkId is not None:
      oprot.writeFieldBegin('mydlinkId', TType.STRING, 4)
      oprot.writeString(self.mydlinkId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRING, 5)
      oprot.writeString(self.trigger.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.keyword is not None:
      oprot.writeFieldBegin('keyword', TType.STRING, 6)
      oprot.writeString(self.keyword.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findRecords_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Record, Record.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype131, _size128) = iprot.readListBegin()
          for _i132 in xrange(_size128):
            _elem133 = Record()
            _elem133.read(iprot)
            self.success.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter134 in self.success:
        iter134.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDeviceByDeviceId_args(object):
  """
  Attributes:
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 1
  )

  def __init__(self, deviceId=None,):
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeviceByDeviceId_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 1)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDeviceByDeviceId_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeviceByDeviceId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserByEmail_args(object):
  """
  Attributes:
   - email
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'email', None, None, ), # 1
  )

  def __init__(self, email=None,):
    self.email = email

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.email = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserByEmail_args')
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 1)
      oprot.writeString(self.email.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserByEmail_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (User, User.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserByEmail_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserByUserId_args(object):
  """
  Attributes:
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
  )

  def __init__(self, userId=None,):
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserByUserId_args')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserByUserId_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (User, User.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserByUserId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendEventNotification_args(object):
  """
  Attributes:
   - deviceEventNotification
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deviceEventNotification', (DeviceEventNotification, DeviceEventNotification.thrift_spec), None, ), # 1
  )

  def __init__(self, deviceEventNotification=None,):
    self.deviceEventNotification = deviceEventNotification

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deviceEventNotification = DeviceEventNotification()
          self.deviceEventNotification.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendEventNotification_args')
    if self.deviceEventNotification is not None:
      oprot.writeFieldBegin('deviceEventNotification', TType.STRUCT, 1)
      self.deviceEventNotification.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendEventNotification_result(object):
  """
  Attributes:
   - success
   - ide
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ide=None,):
    self.success = success
    self.ide = ide

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendEventNotification_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 1)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchDeviceEventLog_args(object):
  """
  Attributes:
   - token
   - deviceId
   - severities
   - startTime
   - endTime
   - total
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.I32, 'severities', None, None, ), # 3
    (4, TType.I64, 'startTime', None, None, ), # 4
    (5, TType.I64, 'endTime', None, None, ), # 5
    (6, TType.I32, 'total', None, None, ), # 6
  )

  def __init__(self, token=None, deviceId=None, severities=None, startTime=None, endTime=None, total=None,):
    self.token = token
    self.deviceId = deviceId
    self.severities = severities
    self.startTime = startTime
    self.endTime = endTime
    self.total = total

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.severities = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.endTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.total = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchDeviceEventLog_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.severities is not None:
      oprot.writeFieldBegin('severities', TType.I32, 3)
      oprot.writeI32(self.severities)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 4)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 5)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    if self.total is not None:
      oprot.writeFieldBegin('total', TType.I32, 6)
      oprot.writeI32(self.total)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchDeviceEventLog_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype138, _size135) = iprot.readListBegin()
          for _i139 in xrange(_size135):
            _elem140 = {}
            (_ktype142, _vtype143, _size141 ) = iprot.readMapBegin() 
            for _i145 in xrange(_size141):
              _key146 = iprot.readString().decode('utf-8')
              _val147 = iprot.readString().decode('utf-8')
              _elem140[_key146] = _val147
            iprot.readMapEnd()
            self.success.append(_elem140)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchDeviceEventLog_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.MAP, len(self.success))
      for iter148 in self.success:
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter148))
        for kiter149,viter150 in iter148.items():
          oprot.writeString(kiter149.encode('utf-8'))
          oprot.writeString(viter150.encode('utf-8'))
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ackAlarm_args(object):
  """
  Attributes:
   - token
   - deviceId
   - startTime
   - endTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
    (3, TType.I64, 'startTime', None, None, ), # 3
    (4, TType.I64, 'endTime', None, None, ), # 4
  )

  def __init__(self, token=None, deviceId=None, startTime=None, endTime=None,):
    self.token = token
    self.deviceId = deviceId
    self.startTime = startTime
    self.endTime = endTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.endTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ackAlarm_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 3)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 4)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ackAlarm_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ackAlarm_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUnreadAlarms_args(object):
  """
  Attributes:
   - token
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, token=None, deviceId=None,):
    self.token = token
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUnreadAlarms_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUnreadAlarms_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUnreadAlarms_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNotificationSetting_args(object):
  """
  Attributes:
   - token
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deviceId', (DeviceId, DeviceId.thrift_spec), None, ), # 2
  )

  def __init__(self, token=None, deviceId=None,):
    self.token = token
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deviceId = DeviceId()
          self.deviceId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNotificationSetting_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRUCT, 2)
      self.deviceId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNotificationSetting_result(object):
  """
  Attributes:
   - success
   - iae
   - ide
   - ioe
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ide', (InvalidDeviceException, InvalidDeviceException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ioe', (InvalidOwnerException, InvalidOwnerException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, iae=None, ide=None, ioe=None,):
    self.success = success
    self.iae = iae
    self.ide = ide
    self.ioe = ioe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ide = InvalidDeviceException()
          self.ide.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ioe = InvalidOwnerException()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNotificationSetting_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    if self.ide is not None:
      oprot.writeFieldBegin('ide', TType.STRUCT, 2)
      self.ide.write(oprot)
      oprot.writeFieldEnd()
    if self.ioe is not None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 3)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerMobileToken_args(object):
  """
  Attributes:
   - token
   - mobileToken
   - displayName
   - mobileType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'mobileToken', None, None, ), # 2
    (3, TType.STRING, 'displayName', None, None, ), # 3
    (4, TType.I32, 'mobileType', None, None, ), # 4
  )

  def __init__(self, token=None, mobileToken=None, displayName=None, mobileType=None,):
    self.token = token
    self.mobileToken = mobileToken
    self.displayName = displayName
    self.mobileType = mobileType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mobileToken = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.displayName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.mobileType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerMobileToken_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.mobileToken is not None:
      oprot.writeFieldBegin('mobileToken', TType.STRING, 2)
      oprot.writeString(self.mobileToken.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 3)
      oprot.writeString(self.displayName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.mobileType is not None:
      oprot.writeFieldBegin('mobileType', TType.I32, 4)
      oprot.writeI32(self.mobileType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerMobileToken_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerMobileToken_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeMobileToken_args(object):
  """
  Attributes:
   - appToken
   - mobileTokens
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'appToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.LIST, 'mobileTokens', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, appToken=None, mobileTokens=None,):
    self.appToken = appToken
    self.mobileTokens = mobileTokens

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.appToken = AccessToken()
          self.appToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.mobileTokens = []
          (_etype154, _size151) = iprot.readListBegin()
          for _i155 in xrange(_size151):
            _elem156 = iprot.readString().decode('utf-8')
            self.mobileTokens.append(_elem156)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeMobileToken_args')
    if self.appToken is not None:
      oprot.writeFieldBegin('appToken', TType.STRUCT, 1)
      self.appToken.write(oprot)
      oprot.writeFieldEnd()
    if self.mobileTokens is not None:
      oprot.writeFieldBegin('mobileTokens', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.mobileTokens))
      for iter157 in self.mobileTokens:
        oprot.writeString(iter157.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeMobileToken_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeMobileToken_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listMobileToken_args(object):
  """
  Attributes:
   - accessToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (AccessToken, AccessToken.thrift_spec), None, ), # 1
  )

  def __init__(self, accessToken=None,):
    self.accessToken = accessToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = AccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listMobileToken_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listMobileToken_result(object):
  """
  Attributes:
   - success
   - iae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(MobileToken, MobileToken.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'iae', (InvalidAccessTokenException, InvalidAccessTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, iae=None,):
    self.success = success
    self.iae = iae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype161, _size158) = iprot.readListBegin()
          for _i162 in xrange(_size158):
            _elem163 = MobileToken()
            _elem163.read(iprot)
            self.success.append(_elem163)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.iae = InvalidAccessTokenException()
          self.iae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listMobileToken_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter164 in self.success:
        iter164.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iae is not None:
      oprot.writeFieldBegin('iae', TType.STRUCT, 1)
      self.iae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendTxtMsgToGsenderQueue_args(object):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendTxtMsgToGsenderQueue_args')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendTxtMsgToGsenderQueue_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendTxtMsgToGsenderQueue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
